# 北京思特奇2023年校招笔试（Java）

1、表达式 (short)10/10.2*2 运算后结果是什么类型？

> 答案：double，浮点数默认是double，自动类型向上转换为浮点数类型



2、 serialVersionUID 字段必须是什么类型？

> 想了解这个字段的类型，首先要了解序列化和反序列化是什么？
>
> **序列化：**指将对象转换为字节序列的过程，也就是将对象的信息转换成文件保存。 ’
>
> **反序列化：**将字节序列转换成目标对象的过程，也就是读取文件，并转换为对象。
>
> serialVersionUID 是用作Serializable类中的版本控件。
>
> JVM将根据您的Serializable类，在类进行序列化的时候自动生成一个serialVersionUID，在序列化完毕后，如果我们对反序列化之前对类的方法或者属性进行了修改的话，在反序列化的时候就会报错。
>
> 但是如果我们确定了==private static final long serialVersionUID = 1L; ==那么即使我们改变了类，曾经序列化的对象在反序列化的时候也不会出错。
>
> 所以答案为：static final long



3、以下对JDBC事务描述错误的是

JDBC事务属于JAVA事务的一种【正确】

JDBC事务属于容器事务类型【错误】

> JDBC 事务是用 Connection 对象控制的。JDBC Connection 接口（ java.sql.Connection ）提供了两种事务模式：**自动提交**和**手工提交**。
>
> JTA（Java Transaction API）事务，是一种高层的，与实现无关的，与协议无关的API，应用程序和应用服务器可以使用JTA来访问事务，JTA允许应用程序执行**分布式**事务处理——在两个或多个网络计算机资源上访问并且更新数据，这些数据可以分布在多个数据库上。JDBC驱动程序的JTA支持极大地增强了数据访问能力。
>
> 容器事务主要是J2EE应用服务器提供的，容器事务大多是基于JTA完成，这是一个基于JNDI的，相当复杂的API实现。
>
> 小结：
>
> 1、JDBC事务控制的局限性在一个数据库连接内，但是其使用简单。
> 2、JTA事务的功能强大，事务可以跨越多个数据库或多个DAO，使用也比较复杂。
> 3、容器事务，主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。
>
> 部分内容来自CSDN（侵联删）



4、下面哪个基于Unicode字符的输出流？

Reader

Writer【正确】

InputStream

OutputStream

> 类名以stream结尾的都是字节流；类名以reader或者writer结尾的都是字符流。
>
> 输入输出是相对于计算机内存为主体的，所以写是输出，读是输入。



5、线程池的状态有哪些？

RUNNING：运行状态，线程池创建好之后就会进入此状态，如果不手动调用关闭方法，那么线程池在整个程序运行期间都是此状态。

SHUTDOWN：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。

STOP：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。

TIDYING：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。

TERMINATED：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。

链接：https://juejin.cn/post/7078126482316328990
来源：稀土掘金

![image-20220926212611594](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220926212611594.png)



6、对于以下说法，哪些是正确的？

如果package语句存在，则必须出现在源文件的非空白首行【正确】

如果import语句存在，则必须出现在源文件的非空白首行【import是写在package下】

如果main()方法存在，则必须出现在源文件的非空白首行【放在任意类的任意一个地方】

如果在原文件中声明了一个public接口，则其名称必须和源文件名一致【正确】



7、关于synchronized和 java.util.concurrent.locks.Lock说法正确的是

Lock能完成synchronized所实现的所有功能【正确】

Lock有比synchronized更精确的线程语义和更好的性能【正确】

synchronized会自动释放锁，而Lock一定要求程序员手工释放finally【正确】

synchronized和Lock释放锁必须在finally从句中释放【仅Lock】



8、javax.Servlet的包中，属于类的是？

Servlet【接口】

GenericServlet【GenericServlet是Servlet**接口的实现类**，但它是一个抽象类，唯一的抽象方法是service()方法】

ServletException【类】

ServletContext【ServletContext接口是一个Servlet的环境对象，Servlet引擎通过该对象向Servlet提供环境信息。】



9、线程阻塞方式？

**融合join**【让一个线程等待另一个线程完成才继续执行。如A线程执行体中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完为止，A才能继续执行】

**睡眠sleep**【让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。】

**让步yield**【从运行状态转换到就绪状态，CPU从就绪状态线程队列中只会选择与该线程优先级相同或更高的线程执行。】

**等待wait**【wait用于Object对象，发出wait后。可以通过notify和notifyAll来唤醒线程。但是只能用于synchronized同步块中】

sleep不出让系统资源，wait是进入线程等待池等待，让出系统资源，其他线程可以占用CPU，一般wait不会加时间限制。



---



## Java类的序列化和反序列化

**序列化：**指将对象转换为字节序列的过程，也就是将对象的信息转换成文件保存。 

**反序列化：**将字节序列转换成目标对象的过程，也就是读取文件，并转换为对象。

**几个关键点：**

- 必须实现Serializable接口才可以进行序列化
- 字段属性 **serialVersionUID** 决定了被修改后的类（比如增加或删除了一个字段），序列化和反序列化是否成功【相当于验证版本一致性的编号】



**这个字段可以自定义，也可以用IDE生成，还可以调用方法生成**

**自定义**比如： private static final long serialVersionUID = 1L;

**使用编译器生成需要设置一下：**

![image-20220926223215070](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220926223215070.png)

![image-20220926223407020](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220926223407020.png)

![image-20220926223423811](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220926223423811.png)

**使用代码生成可以这样写：**

```java
ObjectStreamClass c = ObjectStreamClass.lookup(Student.class);
long serialID = c.getSerialVersionUID();
System.out.println(serialID);
```

> 建议自己指定一个ID，因为如果是自动生成的话，可能会存在版本不同的问题。
>
> ！！！记住这个字段的类型是static final long ！！！



下面上代码：

待序列化的类**Student**

```java
package serializable;

/**
 * @author Administrator
 * @date 2022-09-26 21:47
 */
// 实现Serializable接口的学生类
import java.io.Serializable;
public class Student implements Serializable {
	private static final long serialVersionUID = -575577087488357438L;
	private int age;
	private String name;
	public Student(int age, String name) {
		this.age = age;
		this.name = name;
	}
	@Override
	public String toString() {
		return "Student{" +
				"age=" + age +
				", name='" + name + '\'' +
				'}';
	}
}
```

序列化和反序列化测试类**STest**

```java
package serializable;

import java.io.*;

/**
 * @author Administrator
 * @date 2022-09-26 21:48
 */
public class STest {
	public static void main(String[] args) {
		serial();
		deserial();
	}
	// 序列化方法
	private static void serial(){
		Student student = new Student(21, "John");
		try {
			// FileOutputStream流是指文件字节输出流，
			// 专用于输出原始字节流如图像数据等，其继承OutputStream类，拥有输出流的基本特性
			FileOutputStream fileOutputStream = new FileOutputStream("Student.txt");
			// 对象的序列化流，作用：把对象转成字节数据的输出到文件中保存，
			// 对象的输出过程称为序列化，可实现对象的持久存储。
			ObjectOutputStream objectOutputStream= new ObjectOutputStream(fileOutputStream);
			objectOutputStream.writeObject(student);
			objectOutputStream.flush();
		} catch (Exception exception) {
			exception.printStackTrace();
		}
	}
	// 反序列化方法
	private static void deserial() {
		try {
			FileInputStream fis = new FileInputStream("Student.txt");
			// ObjectInputStream 反序列化流，
			// 将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象。
			// 构造方法 ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。
			ObjectInputStream ois = new ObjectInputStream(fis);
			Student student = (Student) ois.readObject();
			ois.close();
			System.out.println(student.toString());
		}catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	}
}
```



直接运行STest的main方法，可以看到生成了Student.txt字节流序列化文件，再次调用反序列化方法deserial可以看到控制台成功输出了Student对象的信息。【因为重写了toString方法，所以输出的是字段属性值】

![image-20220926224121345](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220926224121345.png)

![image-20220926224203491](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220926224203491.png)
