# 前言

> 底层基础决定上层建筑，数据结构与算法就是基石之一。

> CPU，内存，磁盘这是计算机三个重要的部件。
>
> `CPU`负责运算(计算)。
>
> `内存`和`磁盘`属于数据媒介，负责`存储`并提供数据。
>
> 数据存储，需要有载体，这个载体，我们称之为`数据结构`

**JVM是运行在内存中，所以这里的存储媒介我们讲的是内存**

# 1. 数组

> `数组`是一组`连续内存空间`存储的具有`相同类型`的数据，是一种`线性结构`。

![image-20221001101700501](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101700501.png)

`优势是什么？`

1. `类型固定`: 意味着长度固定
2. `连续内存空间`
3. 因为上述两点特性，基于初始地址，可以计算数组任意位置的内存地址，所谓的`查询快`
4. `随机存取`：通过下标直接访问，即访问第N个元素，不需要访问前(N-1)个数据
5. `顺序存储`：在内存中按顺序存放

`劣势是什么?`

1. 数据初始化需要连续的内存空间，数据在内存当中是随机存放的，不一定有指定长度的连续空间
2. 当插入数据的时候，为了保持连续性，需要做数据迁移（想想如果，添加一个数据，需要向后移动一位，但是如果这一位被其他数据占用了，那么整个数组都需要进行迁移，找到能存放下的内存空间）
3. 同样的道理，删除的时候，也需要做数据迁移

**注意事项：尽量在数组初始化的时候，就确定其大小，数组适合读多的场景**

## 1.1 实现

~~~xml
<properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
        <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
        <encoding>UTF-8</encoding>
    </properties>
~~~



~~~java
package com.mszlu.alg.structs;

import java.util.Arrays;
import java.util.Iterator;

public class MsArrayList<E> implements Iterable<E> {

    private Object[] elementData;
    public MsArrayList(int capacity){
        //初始化 设定容量
        elementData = new Object[capacity];
    }

    public boolean add(E element){
        //添加的时候 往尾部追加
        int size = elementData.length;
        //需要进行扩容，这里只增加一个元素，扩容+1，实际上应该扩容2倍，防止频繁扩容
        int newCapacity = size + 1;
        elementData = Arrays.copyOf(elementData, newCapacity);
        elementData[size] = element;
        return true;
    }

    public E get(int index){
        return (E) elementData[index];
    }

    public int size(){
        return elementData.length;
    }

    public E set(int index,E element){
        int size = elementData.length;
        if (index > size - 1){
            throw new IndexOutOfBoundsException();
        }
        E oldElement = (E) elementData[index];
        elementData[index] = element;
        return oldElement;
    }

    public static void main(String[] args) {
        MsArrayList<String> msArrayList = new MsArrayList<>(10);
        msArrayList.set(0,"1");
        msArrayList.add("11");
        msArrayList.forEach(s -> {
            System.out.println(s);
        });

    }

    @Override
    public Iterator<E> iterator() {
        return new MsIterator();
    }

    class MsIterator implements Iterator<E>{
        int index = 0;
        @Override
        public boolean hasNext() {
            return index != elementData.length;
        }

        @Override
        public E next() {
            return (E) elementData[index++];
        }
    }
}

~~~



# 2. 链表

> 链表一种`非连续`、`非顺序`的存储结构，由一系列节点组成，节点间通过`指针完成了串联`，每个节点包含`数据`和`下一个节点指针`两部分。
>

![image-20221001101711785](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101711785.png)

根据指针的方向可以分为：

- 单向链表
- 循环链表
- 双向链表
- 双向循环链表

`优势是什么？`

1. 不需要连续空间，较灵活
2. `随机存储`：非顺序存储
3. 插入，删除时，只需要更改指针指向即可，开销小

`劣势是什么？`

1. 每个节点除了存储数据，还存储指针，占用额外的空间
2. `顺序存取`：存取第N个数据时，必须先访问前(N-1)个数据，效率低

**链表适合写多的场景**

## 2.1 实现

~~~java
package com.mszlu.alg.structs;


import java.util.Iterator;

public class MsLinkedList<E> implements Iterable<E> {

    private int size;
    private Node<E> first;
    private Node<E> last;

    @Override
    public Iterator<E> iterator() {
        return new MyIterator();
    }
    class MyIterator implements Iterator<E>{
        int index;
        @Override
        public boolean hasNext() {
            return index != size;
        }

        @Override
        public E next() {
            return get(index++);
        }
    }

    private static class Node<E>{
        E item;
        Node<E> prev;
        Node<E> next;

        Node(Node<E> prev,E item,Node<E> next){
            this.prev = prev;
            this.item = item;
            this.next = next;
        }
    }

    public void addLast(E element){
        final Node<E> l = last;
        Node<E> newNode = new Node<>(l,element,null);
        last = newNode;
        if (l == null){
            first = newNode;
        }else{
            l.next = newNode;
        }
        size++;
    }

    public E set(int index, E element){
        Node<E> x = node(index);
        E oldValue = x.item;
        x.item = element;
        return oldValue;
    }

    private Node<E> node(int index) {
        if (index < (size << 1)){
            Node<E> x = first;
            for (int i = 0;i<index;i++){
                x = x.next;
            }
            return x;
        }else{
            Node<E> x = last;
            for (int i = size - 1;i>index;i--){
                x = x.prev;
            }
            return x;
        }
    }

    public E get(int index){
        return node(index).item;
    }

    public static void main(String[] args) {
        MsLinkedList<String> msLinkedList = new MsLinkedList<>();
        msLinkedList.addLast("1");
        msLinkedList.addLast("2");
        msLinkedList.addLast("3");
        msLinkedList.set(1,"set");
        System.out.println(msLinkedList.get(1));
        msLinkedList.forEach(s -> {
            System.out.println(s);
        });
    }
}

~~~



# 3. 栈

> 又名`堆栈`，限定仅在`表尾进行插入和删除`操作的`线性表`（把所有数据用一根线儿串起来，再存储到物理空间中）。
>
> 上面成为`栈顶`，下面称为`栈底`。
>
> 向栈插入新元素称为`入栈`，新元素放到栈顶；从一个栈删除元素又称作`出栈`，它是把栈顶元素删除掉，使其下面相邻的元素成为新的栈顶元素。

![image-20221001101720164](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101720164.png)

根据底层结构不同，可以分为：

1. `数组实现的顺序栈`
2. `链表实现的链式栈`

`优势是什么？`

1. 先进后出，后进先出
2. 只能操作栈顶元素，可控性好，适合特殊场景

`劣势是什么?`

1. 只能操作栈顶元素

`应用场景`

1. JVM的本地方法栈，函数调用
2. 浏览器的前进、后退

## 3.1 实现

数组实现的顺序栈：

~~~java
package com.mszlu.alg.structs;

import java.util.Arrays;

public class ArrayStack<E> {

    private Object[] elementData;

    private int topIndex;

    public ArrayStack(int capacity){
        elementData = new Object[capacity];
    }

    /**
     * 入栈
     * @return
     */
    public boolean push(E element){
        if (topIndex >= elementData.length){
            int newCapacity = elementData.length << 1;
            elementData = Arrays.copyOf(elementData,newCapacity);
        }
        elementData[topIndex++] = element;
        return true;
    }

    /**
     * 出栈 并且删除栈顶元素
     * @return
     */
    public E pop(){
        if (topIndex <= 0){
            throw new RuntimeException("栈为空");
        }
        return (E) elementData[--topIndex];
    }

    /**
     * 出栈
     * @return
     */
    public E peek(){
        if (topIndex <= 0){
            throw new RuntimeException("栈为空");
        }
        return (E) elementData[topIndex-1];
    }

    public static void main(String[] args) {
        ArrayStack<String> arrayStack = new ArrayStack<>(10);
        arrayStack.push("1");
        arrayStack.push("2");
        arrayStack.push("3");

        System.out.println(arrayStack.pop());
        System.out.println(arrayStack.pop());
        System.out.println("--------------");
        System.out.println(arrayStack.peek());
    }
}

~~~

链表实现的链式栈:

~~~java
package com.mszlu.alg.structs;

public class LinkedStack<E> {

    public static class Node<E>{
        E item;
        Node<E> next;

        public Node(E item, Node<E> next){
            this.item = item;
            this.next = next;
        }
    }

    private Node<E> header;
    private int elementCount;

    public boolean push(E element){
        header = new Node<>(element,header);
        elementCount++;
        return true;
    }

    public E pop(){
        if (header == null){
            throw  new RuntimeException("栈为空");
        }
        E item = header.item;
        //删除栈顶元素
        header = header.next;
        elementCount--;
        return item;
    }

    public E peek(){
        if (header == null){
            throw  new RuntimeException("栈为空");
        }
        return header.item;
    }

    public static void main(String[] args) {
        LinkedStack<String> linkedStack = new LinkedStack<>();
        linkedStack.push("1");
        linkedStack.push("2");
        linkedStack.push("3");
        System.out.println("-------------");
        String pop = linkedStack.pop();
        System.out.println("pop:"+pop);
        String peek = linkedStack.peek();
        System.out.println("peek:"+peek);

    }
}

~~~



# 4. 队列

> `队列`是一种特殊的`线性表`，只允许在表的前端进行读取删除操作，而在表的后端进行插入操作。
>
> 和栈一样，队列是一种操作受限制的线性表。
>
> `插入`的数据放在`队尾`，`读取数据`的端称为`队头`。
>
> 队列中没有元素时，称为空队列。

![image-20221001101733667](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101733667.png)

根据底层结构不同，可以分为：

1. `数组实现的顺序队列`
2. `链表实现的链式队列`

根据支持的高级特性，还有以下队列：

1. 循环队列
2. 双端队列
3. 阻塞队列
4. 非阻塞队列

`优势是什么？`

1. 先进先出
2. 规则固定，可控性好，适合特殊场景

`劣势是什么?`

1. 不能直接操作队列中间的元素

`场景举例`

1. 限流
2. 线程池，来不及处理的任务会放入任务队列
3. Kafka，RocketMQ等代表的消息中间件

## 4.1 实现

数组实现：

~~~java
package com.mszlu.alg.structs;

import java.util.Arrays;

public class ArrayQueue<E> {

    private int head;

    private int tail;

    private Object[] elementData;

    public ArrayQueue(int capacity){
        elementData = new Object[capacity];
    }

    /**
     * 入队
     * @param element
     * @return
     */
    public boolean enQueue(E element){
        if (tail >= elementData.length){
            elementData = Arrays.copyOf(elementData,elementData.length << 1);
            if (head != 0){
                //进行一次数据迁移
                if (tail - head >= 0) System.arraycopy(elementData, head, elementData, 0, tail - head);
                tail = tail - head;
                head = 0;
            }
        }
        elementData[tail++] = element;
        return true;
    }

    public E deQueue(){
        if (head == tail){
            throw new RuntimeException("队列为空");
        }
        return (E) elementData[head++];
    }

    public static void main(String[] args) {
        ArrayQueue<String> arrayQueue = new ArrayQueue<>(3);
        arrayQueue.enQueue("1");
        arrayQueue.enQueue("2");
        arrayQueue.enQueue("3");
        System.out.println("---------------------");
        System.out.println(arrayQueue.deQueue());
        arrayQueue.enQueue("4");
        System.out.println(arrayQueue.deQueue());
        System.out.println(arrayQueue.deQueue());
        System.out.println(arrayQueue.deQueue());
        System.out.println("---------------------");
    }
}

~~~

链表实现：

~~~java
package com.mszlu.alg.structs;

public class LinkedQueue<E> {

    private static class Node<E>{
        E item;
        Node<E> next;
        public Node(E item, Node<E> next){
            this.item = item;
            this.next = next;
        }
    }
    private Node<E> head;
    private Node<E> tail;
    private int size;
    public LinkedQueue(){

    }

    public boolean enQueue(E element){
        Node<E> newNode = new Node<>(element,null);
        if (tail == null){
            tail = newNode;
            head = tail;
            return true;
        }
        tail.next = newNode;
        tail = newNode;
        return true;
    }

    public E deQueue(){
        if (head == null){
            throw new RuntimeException("队列为空");
        }
        E item = head.item;
        head = head.next;
        return item;
    }

    public static void main(String[] args) {
        LinkedQueue<String> arrayQueue = new LinkedQueue<>();
        arrayQueue.enQueue("1");
        arrayQueue.enQueue("2");
        arrayQueue.enQueue("3");
        System.out.println("---------------------");
        System.out.println(arrayQueue.deQueue());
        arrayQueue.enQueue("4");
        System.out.println(arrayQueue.deQueue());
        System.out.println(arrayQueue.deQueue());
        System.out.println(arrayQueue.deQueue());
        System.out.println("---------------------");
    }
}

~~~



# 5. 哈希表

> 哈希表（Hash table）也叫散列表。
>
> 根据`键（Key）`而`直接访问`在内存储存位置的数据结构。
>
> 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
>
> 这个映射函数称为`散列函数`，存放记录的数组称做`散列表`。
>
> 常见的`散列(哈希)函数`有`MD5`、`SHA`、`CRC`等



![image-20221001101744121](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101744121.png)

`优势是什么?`

1. 将数据有效的做了切分，分而治之
2. 通过Key可以直接获取到要查找的数据，查询效率高

`劣势是什么?`

1. 可能存在hash冲突

> 如果有HASH冲突，那么在冲突的位置，将数据构建为链表结构，极端情况下，HASH表可能会退化为链表，所有元素都被存储在同一个节点的链表中。O(n)
>
> `装载因子=哈希表中的元素个数 / 哈希表长度`，如果装载因子过大，说明链表的长度越长，性能越低，哈希表需要进行扩容，将数据迁移到新的哈希表中。

`场景举例：`

1. Redis
2. HashMap

## 5.1 实现

~~~java
package com.mszlu.alg.structs.hash;

import org.w3c.dom.Node;

public class MsHashTable<K,V> {

    //散列表 数组结构 (每一个元素上 是一个链表结构)
    private Node<K,V>[] table;

    private static class Node<K,V>{
        //hash函数计算的结果
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        public Node(int hash,K key,V value,Node<K,V> next){
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public MsHashTable(int capacity){
        table = (Node<K, V>[]) new Node[capacity];
    }


    public void put(K key,V value){
        //1. 计算hash值
        int hash = hash(key);
        int i = (table.length - 1) & hash;
        Node<K,V> node = new Node<>(hash,key,value,null);
        Node<K, V> kvNode = table[i];
        if (kvNode == null){
            //这个数组位置 没有数据 是第一个
            table[i] = node;
            return;
        }
        //数组位置有值
        //需要判断一下key是否相等，key相等的情况下 进行替换
        if (kvNode.key.equals(key)){
            kvNode.value = value;
        }else{
            kvNode.next = node;
        }
    }

    public V get(K key){
        int hash = hash(key);
        int i = (table.length - 1) & hash;
        Node<K, V> node = table[i];
        if (node == null){
            return null;
        }
        Node<K, V> newNode = node;
        //正常 做一个循环，查找key是否匹配，知道next为null
        while (newNode.next != null){
            if (newNode.key.equals(key)){
                break;
            }
            newNode = newNode.next;
        }
        return newNode.value;
    }

    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

    public static void main(String[] args) {
        MsHashTable<String,String> hashTable = new MsHashTable<>(10);
        hashTable.put("key1","mszlu1");
        hashTable.put("key2","mszlu2");
        hashTable.put("key1","mszlu3");

        System.out.println(hashTable.get("key1"));
        System.out.println(hashTable.get("key2"));
    }
}

~~~



# 6. 图

> 图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：`G（V, E）`，其中 `G 表示一个图`，`V 是图 G 中顶点的集合`，`E 是图 G 中边的集合`。
>

![image-20221001101757946](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101757946.png)

根据图是否有方向、权重等可以分为:

1. 有向图
2. 无向图
3. 带权图

**图主要有以下两种存储方式：**

1. 邻接矩阵。比较浪费空间，但是优点是查询效率高
2. 邻接表。每个顶点对应一个链表，比较节省存储空间，但是查询效率会低些。当然为了提高查询效率，可以将里面的链表替换成红黑树、跳表、或者平衡二叉树。

`优势是什么？`

1. 任意点都可以建立关系，存储的数据量大（信息完备）
2. 可以描述两个顶点之间的关系，称之为`边`

`劣势是什么？`

1. 存储数据量大
2. 图用多维数组表示，将图运算转换为矩阵运算，较为复杂
3. 图稀疏的话，采用邻接表，节省空间

`场景举例：`

1. 地图如何计算出最优出行路线
2. 深度优先搜索
3. 广度优先搜索
4. 最小生成树

**相关术语：**

1. **出度**：由某个顶点指出的边的个数；
2. **入度**：指向某个顶点的边的个数；
3. **有向路径**：由一系列顶点组成，其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点
4. **有向环**：至少含有一条边，且起点和终点相同的有向路径

## 6.1 实现

**两个顶点v和w可能存在的4种关系：**

1. 没有边相连
2. 存在从v到w的边v->w
3. 存在从w到v的边w->v
4. 既存在v->w，也存在w->v，即双向连接

~~~java
package com.mszlu.alg.structs;

public class MsGraph {

    //顶点集合
    private char[] vertex;
    //邻接矩阵
    private int[][] matrix;

    /**
     *
     * @param vexs 顶点数组 {A,B,C,D}
     * @param edges 边数组 {{A,C},{B,A},{B,D},{C,B},{C,D},{D,B}}
     */
    public MsGraph(char[] vexs,char[][] edges){
        int vLen = vexs.length;
        int eLen = edges.length;
        //初始化顶点
        vertex = new char[vLen];
        System.arraycopy(vexs, 0, vertex, 0, vLen);
        //初始化边
        matrix = new int[vLen][vLen];
        for (int i =0;i<eLen;i++){
            //边的起始顶点和结束顶点
            int p1 = getPosition(edges[i][0]);
            int p2 = getPosition(edges[i][1]);
            matrix[p1][p2] = 1;
        }

    }

    public void print(){
        for (int i=0;i<vertex.length;i++){
            for (int j=0;j<vertex.length;j++){
                System.out.printf("%d ",matrix[i][j]);
            }
            System.out.printf("\n");
        }
    }
    private int getPosition(char ch) {
        for (int i = 0;i<vertex.length;i++) {
            if (vertex[i] == ch){
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        char[] vexs = {'A','B','C','D'};
        //{{A,C},{B,A},{B,D},{C,B},{C,D},{D,B}}
        char[][] edges = {
                {'A','C'},
                {'B','A'},
                {'B','D'},
                {'C','B'},
                {'C','D'},
                {'D','B'}
        };
        MsGraph msGraph = new MsGraph(vexs,edges);
        msGraph.print();
    }
}

~~~



# 7. 树

> 树是N (N >= 0 )个节点的有限集合,N = 0 时,称为空树。
>
> 树上的每一个元素称为节点，节点与节点之间有一定的关系，上下称为`父子节点`，左右称为`兄弟节点`。

![image-20221001101807055](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101807055.png)

按照树的表现结构，可以具体分为以下几种类型：

1. 二叉树
2. 平衡二叉树
3. 满二叉树
4. 完全二叉树
5. 递归树
6. 红黑树
7. B- 树
8. B+ 树

**每个节点包含：数据值，左子节点指针，右子节点指针**

`优势是什么？`

1. 树形结构，支持数据的快速插入、查找、删除
2. 支持多种遍历方式：前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）
3. 结构特殊，适合用递归来实现

`劣势是什么?`

1. 删除节点麻烦
2. 删除节点-物理删除，需要重新构造树结构
3. 删除节点-逻辑删除，产生内存碎片

## 7.1 实现

~~~java
package com.mszlu.alg.structs;

public class Tree<E> {

    E item;
    Tree<E> left;
    Tree<E> right;

    public Tree(E item){
        this.item = item;
    }

    public Tree<E> buildLeft(E item){
        this.left = new Tree<>(item);
        return this.left;
    }

    public Tree<E> buildRight(E item){
        this.right = new Tree<>(item);
        return this.right;
    }

    public void printPreOrder(){
        System.out.print(this.item + ">");
        print(this.left);
        print(this.right);
    }
    public void print(Tree<E> node){
        if (node == null) return;
        System.out.print(node.item + ">");
        print(node.left);
        print(node.right);
    }

    public static void main(String[] args) {
        Tree<Integer> root = new Tree<>(10);
        Tree<Integer> left = root.buildLeft(6);
        Tree<Integer> left1 = left.buildLeft(4);
        left1.buildLeft(2);
        left.buildRight(8);
        Tree<Integer> right = root.buildRight(18);
        right.buildLeft(13);
        right.buildRight(20);
        root.printPreOrder();
    }
}

~~~

# 8. 堆

> 一种特殊的二叉树。需要满足两个条件：
>
> 1. 是一棵完全二叉树 
> 2. 堆中每个节点的值必须>=或<=其左右子节点的值。

![image-20221001101643321](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221001101643321.png)

根据每个节点的值是>= 还是 <= 子树中每个节点的值，分为

1. 大顶堆
2. 小顶堆

**节点的值只能比左右子节点，大或者小 只能选择一个**

`优势是什么？`

1. 时间复杂度较低
2. 获取堆顶元素的时间复杂度为 O(1)
3. 假设完全二叉树包含n个节点，插入元素、删除元素，时间复杂度为 O(logn)

`劣势是什么？`

1. 特殊的二叉树，只能用于特定场景

`场景举例：`

1. 堆排序
2. 优先级队列
3. 求 TOP K
4. 求中位数

**三个大于号是【无符号移位运算符】**

## 8.1 实现

~~~java
package com.mszlu.alg.structs;


import java.util.PriorityQueue;

public class HeapNode {

    private int[] heap;
    private int size;

    public  HeapNode(int capacity){
        heap = new int[capacity];
    }


    public void offer(int n){
        int i = size;
        while (i > 0){
            int parent = (i-1) >>> 1;
            int v = heap[parent];
            if (n >= v){
                break;
            }
            heap[i] = v;
            i = parent;
        }
        heap[i] = n;
        size++;
    }

    public int poll(){
        //将堆顶元素 弹出，并且删除
        //需要重新构建堆
        int top = heap[0];
        int[] newHeap = new int[size-1];
        System.arraycopy(heap,1,newHeap,0,size-1);
        heap = new int[heap.length];
        size=0;
        for (int i : newHeap) {
            offer(i);
        }
        return top;
    }

    public int peek(){
        return heap[0];
    }

    public static void main(String[] args) {
        HeapNode heapNode = new HeapNode(6);
        heapNode.offer(4);
        heapNode.offer(3);
        heapNode.offer(6);
        heapNode.offer(2);
        heapNode.offer(9);
        heapNode.offer(7);
        System.out.println(heapNode.peek());
        System.out.println(heapNode.poll());
        heapNode.offer(1);
        System.out.println(heapNode.peek());
    }
}

~~~



**示例：从10亿个数据中找到最大的前10个？**

- 假设10亿个数据存在数组中
- 取前10个数据，构建一个小顶堆，那么根节点是最小的
- 然后，从数组中依次取出一个数据与堆顶比较，如果大于，替换掉堆顶元素，堆内部调整；如果小于等于堆顶，不做处理
- 同样逻辑，依次循环处理数组中每一个元素。
- 当10亿个数据处理完后，堆中的数据就是Top 10

~~~java
package com.mszlu.alg.structs;

import java.util.ArrayList;
import java.util.List;

public class HeapTopK {

	public static void main(String[] args) {
		int[] nums = new int[]{1,5,4,2,3,6};
		System.out.println(topKMax(nums, 5));	//输出：[2, 3, 4, 5, 6]
	}
	
	//寻找前k个最大的数--使用小顶堆
	public static List<Integer> topKMax(int[] nums, int k){
		//寻找前k个最小数，因此将小顶堆大小定义为k
		HeapNode pq = new HeapNode(k);
		for(int i=0; i<nums.length; i++){
			if(i<k){
				pq.offer(nums[i]);	//前k个数，直接入堆
			}else if(nums[i]>pq.peek()){	//如果当前元素比堆顶元素大
				pq.poll();	//说明堆顶元素（堆中最小元素）一定不属于前k大的数，出堆
				pq.offer(nums[i]);	//当前元素有可能属于前k大，入堆
			}
		}
		
		List<Integer> ans = new ArrayList<>();
		while(!pq.isEmpty()){
			ans.add(pq.poll());
		}
		return ans;
	}
}

~~~

> `算法思想`是解决算法问题的核心，而大部分的算法解析思路都来源于以下的`七种算法策略`。
>
> 也就是说，掌握了下面的算法思想，那么就掌握了解题的基本套路

# 1. 递归

> 递归算法是一种直接或者间接`调用自身函数`或者方法的算法。
>
> 递归算法的实质是把`问题分解成规模缩小的同类问题`的`子问题`，然后递归调用方法来表示问题的解。

## 1.1 说明

1. 递归算法实现简单，易上手
2. 递归过深，容易发生`栈溢出`

## 1.2 解析思路

主要用于解决三类问题：

1. 数据的定义是按照递归定义的（斐波那契数列 f(n) = f(n-1) + f(n-2)）
2. 问题的解法按递归实现（回溯）
3. 数据的结构形式按递归定义（树，图）

解题：

1. 明确输入输出，需要完成什么事情
2. `寻找递归结束条件`，结束递归，返回结果
3. 明确`递归关系式`，通过递归组合来解决问题

## 1.3 经典问题

### 1.3.1 斐波那契数列

~~~java
package com.mszlu.alg.recursion;

public class Fibonacci {
    // 0 1 1 2 3 5 8 13 21
    public int fibonacci(int n){
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fibonacci(n-1) + fibonacci(n-2);
    }

    public static void main(String[] args) {
        Fibonacci fibonacci = new Fibonacci();
        System.out.println(fibonacci.fibonacci(4));
    }
}

~~~

### 1.3.2 汉诺塔问题

> 汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/1026866-20161016022859889-2055402664.jpg)

从左到右有A、B、C三根柱子，其中`A柱子`上面有`从小叠到大的n个圆盘`，现要求将`A柱子上的圆盘`移到`C柱子上去`，期间只有一个原则：`一次只能移到一个盘子且大盘子不能在小盘子上面`，`求移动的步骤和移动的次数`

假设n=1：

1. **A(0)->C**   1次

假设n=2:

1. A(0 1)->B(0)
2. **A(1)->C**
3. B->C   3次

假设n=3：

1. A(0 1 2)->C(0)
2. A(1 2)->B(1)
3. C(0)->B(0 1)
4. **A(2)->C(2)**
5. B(0 1)-> A(0)
6. B (1)->C (1 2)
7. A(0)->C(0 1 2) 7次

规律：移动2^n-1次

**分析一下，我们得出，符合以下规律：**

1. 把n-1个盘子 从A移动到B
2. 把第n个盘子从A移动到C
3. 把n-1个盘子从B移动C

代码：

~~~java
package com.mszlu.alg.recursion;

public class Hanoi {

    int moveCount = 0;

    public void move(int id, char src, char dist){
        System.out.println("第"+(++moveCount)+"次移动，将 "+id+" 从"+src+"移动到"+dist);
    }
    //圆盘编号 0-n
    public void hanoi(int n, char A,char B,char C){
        if (n == 1){
            move(0,A,C);
        }else{
            hanoi(n-1,A,C,B);//A到B C辅助
            move(n-1,A,C);
            hanoi(n-1,B,A,C);//B到C A辅助
        }
    }

    public static void main(String[] args) {
        Hanoi hanoi = new Hanoi();
        hanoi.hanoi(3,'A','B','C');
    }
}

~~~



# 2. 分而治之

> 将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，`直到更小的子问题可以简单求解`，求解子问题，则原问题的解则为`子问题解的合并`。

## 2.1 解题思路

当出现满足以下条件的问题，可以尝试只用分治策略进行求解：

1. 原始问题可以分成多个相似的子问题
2. 子问题可以很简单的求解
3. 原始问题的解是子问题解的合并
4. 各个子问题是相互独立的，不包含相同的子问题

**解题思路：**

1. 分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决，解决各个子问题
3. 合并，将各个子问题的解合并为原问题的解

## 2.2 经典问题

### 2.2.1 二分查找

> 又称折半查找，是一种快速查找算法，比如 有 0-100的数，让你猜数字，每猜一次，就告诉你是猜大了还是猜小了，然后再剩下的数中 继续猜，很明显符合分治的思路



~~~java
package com.mszlu.alg.divide;

public class BinarySearch {

    /**
     * 输入数字 查找其在数组中的位置
     * @param items
     * @param item
     * @return
     */
    public int search(int[] items,int item){
        //第一步 分解，选择中间的数，将其分成两部分
        int low = 0;
        int high = items.length - 1;
//        int mid = (low+high)/2;
//        int value = items[mid];
        //第二步 解决子问题，如果比中间数小，去左边找，如果比中间数大 去右边找 相等返回成功
        while (low <= high){
            //第三步 合并
            int mid = (low + high)/2;
            int value = items[mid];
            if (item < value){
                high = mid - 1;
            }else if (item > value){
                low = mid + 1;
            }else {
                return mid;
            }
        }
        //没找到
        return -1;
    }

    public static void main(String[] args) {
        BinarySearch binarySearch = new BinarySearch();
        int[] items = {1,2,3,4,5,6};
        int search = binarySearch.search(items, 5);
        System.out.println(search);
    }
}

~~~



### 2.2.2 归并排序

> 归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。
>
> 每个子序列又重复上述过程，所以还用到了递归

~~~java
package com.mszlu.alg.divide;

public class MergeSort {

    /**
     * 对传入的数组进行排序，指定开始排序的起始位置和结束位置
     * @param array
     * @param start
     * @param end
     */
    public void mergeSort(int[] array, int start, int end){
        //由于是递归，所以需要有退出条件
        if (start < end) {
            //第一步，分解，将其分成左右两部分
            int mid = (start + end) / 2;
            //第二步，解决子问题 对左右子序列 分别排序
            mergeSort(array, 0, mid);
            mergeSort(array, mid + 1, end);
            //第三步，合并
            merge(array, start, mid, end);
        }
    }

    private void merge(int[] array, int left, int mid, int right) {
        //临时存放数组
        int[] tmp = new int[array.length];
        //设置检测指针，分别指向左子序列 和 右子序列的起始 ，同时设置存放指针
        int p1 = left;
        int p2 = mid+1;
        int k = left;
        //比较子序列，结果放入tmp
        while (p1 <= mid && p2 <= right){
            if (array[p1] <= array[p2]){
                tmp[k++] = array[p1++];
            }else {
                tmp[k++] = array[p2++];
            }
        }
        //如果有未检测到的，直接添加到序列最后
        while (p1 <= mid){
            tmp[k++] = array[p1++];
        }
        while (p2 <= right){
            tmp[k++] = array[p2++];
        }
        System.arraycopy(tmp,left,array,left,right+1-left);
    }

    public static void main(String[] args) {
        MergeSort mergeSort = new MergeSort();
        int[] array = {3,9,15,7,2,5,20,10,8,1};
        mergeSort.mergeSort(array,0,array.length-1);
        for (int i : array) {
            System.out.println(i);
        }
    }
}

~~~

# 3. 贪心算法

> 总是做出`当前的最优选择`，即期望`通过局部的最优选择`获得`整体的最优选择`。

**贪心算法仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。**

比如：从100张钞票中 抽取十张，如何才能获得最大的价值。`每次选剩下的最大的面值即可`。

但是有些情况下，局部最优解并不是整体最优解：

比如：求A-G的最短路径，根据贪心算法，会选择A-B，B-E,E-G，1+5+4=10，但是最优解应该是A-C,C-G 2+2=4

![image-20211225120806044](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20211225120806044.png)



## 3.1 解题思路

**什么时候使用贪心算法呢？**

1. 原问题复杂度过高
2. 求全局最优解的数学模型难以建立或计算量过大
3. 没有太大必要一定要求出全局最优解，“比较优”就可以

**解题思路:**

1. 明确什么是最优解
2. 把问题分成多个步骤，每一步都需要满足
    1. 可行性：每一步都满足问题的约束
    2. 局部最优：每一步都做出一个局部最优的选择
    3. 不可取消：选择一旦做出，在后面遇到任何情况都不可取消
3. 叠加所有步骤的最优解，就是全局最优解

## 3.2 经典问题

### 3.2.1 活动安排问题

> 设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si< fi。如果选择了活动i，则它在半开时间区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当si>fj或sj>fi时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。



~~~java
package com.mszlu.alg.gpeedy;

import java.util.ArrayList;
import java.util.List;

public class Activity {

    /**
     * 如果结束时间 不符合升序，应该 先进行排序
     * @param start 活动开始时间 {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12}
     * @param end 活动结束时间  结束时间 按照时间 升序排列 {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
     */
    public void arrange(int[] start, int[] end){
        //活动时间 最短的 为最优解
        List<Integer> result = arrangeActivity(start,end);
        for (int i = 0; i< result.size(); i++){
            int index = result.get(i);
            System.out.println("开始时间:"+start[index]+"，结束时间:"+end[index]);
        }
    }

    private List<Integer> arrangeActivity(int[] start, int[] end) {
        int total = start.length;
        int endFlag = end[0];
        List<Integer> result = new ArrayList<>();
        result.add(0);
        for (int i = 0; i< total;i++){
            if (start[i] > endFlag){
                result.add(i);
                endFlag = end[i];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Activity activity = new Activity();
        int[] start = {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
        int[] end = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        activity.arrange(start,end);
    }
}

~~~



### 3.2.2 找零钱问题

> 我买了一个商品，老板要找给我99，他有面值分别为25，10，5，1的硬币数，为了找给我最少的硬币数，那么他应该怎么找？
>
> 先看看该找多少个25分的，99／25＝3，那么老板只能给我3个25分的，由于还少给我24，所以还得给我2个10分的和4个1分。

~~~java
package com.mszlu.alg.gpeedy;

public class Money {

    public void give(int[] m, int target){

        int[] results = giveMoney(m,target);
        System.out.println(target + "的找钱方案:");
        for (int i = 0; i < results.length; i++) {
            System.out.println(results[i] + "枚" + m[i] + "面值");
        }
    }

    private int[] giveMoney(int[] m, int target) {
        int length = m.length;
        int[] nums = new int[length];		//  
        for (int i=0;i<length;i++){
            nums[i] = target / m[i];
            target = target % m[i];
        }
        return nums;
    }

    public static void main(String[] args) {
        int[] m = {25,10,5,1};
        new Money().give(m,99);
    }
}

~~~



# 4. 回溯算法

> 回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。`深度优先搜索`利用的就是回溯算法思想。

## 4.1 解题思路

回溯算法很简单，它就是不断的尝试，直到拿到解。

**解题思路：**

1. 针对所给问题，确定问题的`解空间`(所有可能的解构成的集合)
    1. 首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。
2. 把问题的解空间转化为图或者树的结构表示，确定节点的扩展搜索规则
3. 使用深度优先搜索策略进行遍历，并在搜索过程中用剪枝函数避免无效搜索
4. 遍历的过程中记录和寻找所有可行解或者最优解。

> ​	回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用**剪枝函数**判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。
>
> ​    回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。
>
> ​    问题的关键在于如何定义问题的解空间，转化成树（即解空间树）



## 4.2 经典问题

### 4.2.1 八皇后

> 该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：
>
> 在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 
> 八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解



以n=4为例：

![image-20211227192841085](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20211227192841085.png)

代码：

~~~java
package com.mszlu.alg.recall;

public class NQueen {

    int n = 4;
    int[][] boards = new int[n][n];
    int result = 0;
    /**
     * 放入棋子，从0开始放入
     * @param k
     */
    public void put(int k){
        //确定解空间，每行每列放置棋子的集合
        //搜索规则，从下一个棋子开始，进行放置
        //剪枝函数，判断棋子是否能放置(不能一列，不能在一条斜线)，能放置，就得到一个解
        //如果都不满足，则进行回溯
        if (k == n){
            //放置结束
            result++;
            //打印
            for (int i=0;i<n;i++){
                for (int j=0;j<n;j++){
                    System.out.print(boards[i][j]+" ");
                }
                System.out.println();
            }
            System.out.println();
        }else{
            for (int i=0;i<n;i++){
                if (check(k,i)){
                    boards[k][i] = 1;
                    put(k+1);
                    //不是最优解 设为0
                    boards[k][i] = 0;
                }
            }
        }
    }

    private boolean check(int row, int col) {
        //检查是不是在一列上
        for (int i=0;i<row;i++){
            if (boards[i][col]==1){
                return false;
            }
        }
        //左斜杠上
        for(int i=row-1, j=col-1; i>=0 && j >= 0; i--, j--) {
            if (boards[i][j] == 1) {
                return false;
            }
        }
        //右斜杠上
        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++) {
            if (boards[i][j] == 1) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        NQueen nQueen = new NQueen();
        nQueen.put(0);

        System.out.println(nQueen.result);
    }
}

~~~



# 5. 动态规划

> 动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。

动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。

## 4.1 解题思路

动态规划适用于`求解最优解问题`，比如，从面额不定的100个硬币中任意选取多个凑成10元，求怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够了10元。这就是一个`典型的动态规划`问题。它可以分成`一个个子问题`（每次选取硬币），每个子问题又有`公共的子子问题`（选取硬币），`子问题之间相互关联`（已选取的硬币总金额不能超过10元），`边界条件就`是最终选取的硬币总金额为 10 元。

**解题思路：**

1. 定义子问题
2. 实现需要反复执行解决的子子问题部分
3. 识别并求解出边界条件

## 4.2 经典问题

### 4.2.1 爬楼梯问题

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**第一步：定义子问题**

如果用f(n)表示第 `n` 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 `n` 级台阶的方案数等于第 `n-1` 级台阶的方案数加上第 `n-2` 级台阶的方案数

**第二步：实现需要反复执行解决的子子问题部分**

~~~java
f(n) = f(n-1) + f(n-2)
~~~

**第三步：识别并求解出边界条件**

~~~java
//0,一种方案 ,第1级也是一种方案
f(0) = 1;
f(1) = 1;
~~~

代码：

~~~java
package com.mszlu.alg.dynamic;

public class Stairway {

    public int climb(int n){
        if (n == 0) return 1;
        if (n == 1) return 1;
        int result = 2;
        for (int i=2;i<=n;i++){
            result = climb(i-1) + climb(i-2);
        }
        return result;
    }

    public int climb1(int n){
        int result = 1;
        int n1 = 1;
        int n2 = 1;
        for (int i=2;i<=n;i++){
            result = n1 + n2;
            n1 = n2;
            n2 = result;
        }
        return result;

    }
    public static void main(String[] args) {
        int climb = new Stairway().climb1(4);
        System.out.println(climb);
    }
}

~~~



# 6. 枚举策略

> 枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的

## 6.1 解题思路

- 确定枚举对象、枚举范围和判定条件。
- 逐一列举可能的解，验证每个解是否是问题的解。

枚举算法步骤：

1. 确定解题的可能范围，不能遗漏任何一个真正解，同时避免重复。

2. 判定是否是真正解的方法。

3. 为了提高解决问题的效率，使可能解的范围将至最小，

## 6.2 经典问题

### 6.2.1 百钱买鸡

> 公鸡每只5元，母鸡每只3元，三只小鸡1元，用100元买100只鸡，问公鸡、母鸡、小鸡各多少只？

算法分析：

利用枚举法解决该问题，

以三种鸡的个数为枚举对象,分别设为mj,gj和xj，

用三种鸡的总数 （mj+gj+xj=100）和买鸡钱的总数（1/3*xj+mj*3+gj*5=100）作为判定条件，穷举各种鸡的个数。

~~~java
package com.mszlu.alg.enums;

public class BuyChicken {

    public static void main(String[] args) {
        int mj = 0;
        int gj = 0;
        int xj = 0;
        //公鸡每只5元 最多20只，母鸡每只3元 最多33只
        for (gj=0;gj<=20;gj++){
            for (mj=0;mj<=33;mj++){
                xj = 100 - gj - mj;
                if (xj%3 == 0 && (5*gj + 3*mj + xj/3 == 100)){
                    System.out.println("总共需要买小鸡："+xj+",母鸡:"+mj+",公鸡:"+gj);
                }
            }
        }
    }
}

~~~

# 7. 分支限界法

> 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的`最优解`。

所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。

选择下一个结点的方式不同，则会有几种不同的分支搜索方式：

- FIFO搜索（先进先出 队列）
- LIFO搜索 （后进先出 栈）
- 优先队列式搜索

## 7.1 解题思路

1. 定义解空间 确定解空间包括解的组织形式和显约束(范围限定)
2. 确定解空间的组织结构 通常用解空间树形象的表达(只是辅助理解并不是真的树)
3. 搜索解空间 按照**广度优先搜索**，根据限制条件，搜索问题的解

## 7.2 经典问题

### 7.2.1 背包问题

> 设有n个物体和一个背包,物体i的重量为wi价值为pi ,背包的载荷为M, 若将物体i（1<= i <=n）装入背包,则有价值为pi . 目标是找到一个方案, 使得能放入背包的物体总价值最高.
>
> 设N=3, W=(16,15,15),  P=(45,25,25), C=30（背包容量）

**队列式分支限界法**

可以通过画分支限界法状态空间树的搜索图来理解具体思想和流程

每一层按顺序对应一个物品放入背包（1）还是不放入背包（0）

![image-20220104202210193](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220104202210193.png)

步骤：

**①** 用一个队列存储活结点表，初始为空

**②** A为当前扩展结点，其儿子结点B和C均为可行结点，将其按从左到右顺序加入活结点队列，并舍弃A。

**③** 按FIFO原则，下一扩展结点为B，其儿子结点D不可行，舍弃；E可行，加入。舍弃B

**④** C为当前扩展结点，儿子结点F、G均为可行结点，加入活结点表，舍弃C

**⑤** 扩展结点E的儿子结点J不可行而舍弃；K为可行的叶结点，是问题的一个可行解，价值为45

**⑥** 当前活结点队列的队首为F, 儿子结点L、M为可行叶结点，价值为50、25

**⑦** G为最后一个扩展结点，儿子结点N、O均为可行叶结点，其价值为25和0

**⑧** 活结点队列为空，算法结束，其最优值为50

注：活结点就是不可再进行扩展的节点，也就是两个儿子还没有全部生成的节点

代码：

~~~java
package com.mszlu.alg.limit;

public class Node {
    //物品的总重量
    private int weight;
    //物品的总价值
    private int value;
    //节点所在的层
    private int level;
    //记录父节点
    private Node parent;
    //节点是否被选择
    private boolean isLeft;

    public Node(int weight, int value, int level, Node parent, boolean isLeft) {
        this.weight = weight;
        this.value = value;
        this.level = level;
        this.parent = parent;
        this.isLeft = isLeft;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent = parent;
    }

    public boolean isLeft() {
        return isLeft;
    }

    public void setLeft(boolean left) {
        isLeft = left;
    }
}

~~~



~~~java
package com.mszlu.alg.limit;

import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

public class Knapsack {
    //记录最优解的节点
    private static Node bestNode;
    //广度遍历需要的FIFO队列
    private static Queue<Node> queue = new ArrayBlockingQueue<>(3);

    private static int w[] = { 16,15,15 };//物品的重量
    private static int v[] = { 45, 25, 25 };//物品的价值
    private static int c = 30;//背包的容量
    private static int cw = 0;//已选择物品的重量
    private static int cv = 0; //已选择物品的价值
    private static int bestV = 0; //装入背包的物品的最优价值
    private static int n = w.length; //物品的个数

    public static void main(String[] args) {
        Node parent = null;
        int i = 0; //起始层数
        while (i < n){
            //选择物品i
            int tw = cw + w[i];
            if (tw <= c){
                //重量符合
                if (cv + v[i] > bestV){
                    bestV = cv + v[i];
                }
                //将左孩子 做为活节点 加入队列
                addLiveNode(cw + w[i],cv+v[i],i+1,parent,true);
            }
            //不选择物品i
            int bound = maxBound(i);
            if (cv + bound > bestV){
                addLiveNode(cw,cv,i+1,parent,false);
            }
            Node node = queue.poll();
            i = node.getLevel();
            cw = node.getWeight();
            cv = node.getValue();
            parent = node;
        }
        System.out.println(bestV);
        for (int j=n-1;j>=0;j--){
            System.out.println(bestNode.isLeft() ? 1 : 0);
            bestNode = bestNode.getParent();
        }
    }

    private static int maxBound(int i) {
        int bound = 0;
        for (int level = i+1;level<n;level++){
            bound += v[level];
        }
        return bound;
    }

    private static void addLiveNode(int w, int v, int level, Node parent, boolean isLeft) {
        Node node = new Node(w,v,level,parent,isLeft);
        queue.add(node);
        if (level == n && v == bestV){
            bestNode = node;
        }
    }


}

~~~

# 8. 时间复杂度

**时间复杂度是一个函数，它定性描述该算法的运行时间**。

我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。

那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。

> 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为O(f(n))。



## 8.1 O(n)等表示什么？

我们常说的时间复杂度 `O(n)`,`O(n^2)`,`O(logn)`等指的是，算法在最坏的情况下运行时间的上界。

简单理解：**代表某个算法的耗时与数据增长量之间的关系。其中的n代表输入数据的量，以最坏的情况来计算**

> 有时候也有例外，主要看探讨复杂度的时候，输入的数据用例不同，复杂度也可能是不同的，同时有些复杂度有些默认规则，比如快排时间复杂度为O(nlogn)，但是最坏的情况，时间复杂度为O(n^2)

`时间复杂度为O(n)`，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。 

`时间复杂度O(n^2)`，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 

`时间复杂度O(logn)`，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。

`时间复杂度O(nlogn)`，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 

`时间复杂度O(1)`就是最低的时间复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）

> 计算复杂度的时候，会忽略常数项，比如 O(100n)就是O(n)的复杂度，O(5n^2) 就是O(n^2)的时间复杂度，但是我们可以看的出来，比如当n=10的时候，O(100n)的用时很明显比O(5n^2)的要多，但是一般情况下，我们默认O(n)的效率要高于O(n^2)

**大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量**。

其他的复杂度 还有 指数级增长O(2^n)，立方阶O(n^3)

## 8.2 复杂表达式的化简

> 有时候我们去计算时间复杂度的时候发现不是一个简单的O(n) 或者O(n^2)， 而是一个复杂的表达式，这时候如何去描述呢？

例如：

~~~java
O(2*n^2 + 10*n + 1000)
~~~

首先我们去掉`常数项`

~~~java
O(n^2 + n)
~~~

**如果数据规模大的话，n的影响极低，所以可以将n去掉，最终时间复杂度为：**

~~~java
O(n^2)
~~~

## 8.3 总结

> 在解题的时候，我们往往可以通过分析时间复杂度来确定算法的效率，也就是找出其中的最优解法。所以在面试的时候，面试官往往在你给出一种非最优解后，询问是否还有更优的解法（时间复杂度低的）。所以这里有一个套路，如果一道题你知道几种解法，先给出一个不算太优的，然后等面试官问，然后再给出最优解（顺便做思考状，还可以让面试官给点提示）。

# 9. 空间复杂度

> 算法在运行过程中占用内存空间大小的量度，依旧用O(f(n)）表示。

**利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先`估计`。**

注意：算法的空间复杂度并不是计算实际占用的空间，而是**计算整个算法的辅助空间单元的个数**

## 9.1 如何计算

~~~java
public int climb1(int n){
        //边界条件
        int result = 1;
        //前n-2的台阶数
        int n1 = 1;
        //前n-1的台阶数
        int n2 = 1;
        for (int i=2;i<=n;i++){
            result = n1 + n2;
            n1 = n2;
            n2 = result;
        }
        return result;
    }
~~~

以我们之前写过的`爬楼梯`代码分析，随着n的变化，内存空间并不会随着n的变化而变化，此时我们说上述代码的空间复杂度为`O(1)`

~~~java
int array = new int(n);
for (int i = 0; i < n; i++) {
    array[i] = i;
}
~~~



从上述代码分析可以得出，主要是array数组在占用空间，随着n的增大，内存空间的占用线性增长，所以上述代码的空间复杂度为`O(n)`

> 空间复杂度为O(logn) 一般出现在递归上，递归的空间复杂度计算公式：递归深度N*每次递归所要的辅助空间，如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)。
>
> 比如二分法，用递归的时候，递归深度为 log(n), 空间复杂度就为O（logn）

