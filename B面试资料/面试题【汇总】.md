# 面试题

# 8种基本数据类型

![image-20220818215400709](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220818215400709.png)

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |
| ------------ | ------- | -------- | ------------------------------------------ |
| 字节型       | byte    | 1 字节   | -128~127                                   |
| 短整型       | short   | 2 字节   | -32768~32767                               |
| 整型         | int     | 4 字节   | -2147483648~2147483647                     |
| 长整型       | long    | 8 字节   | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float   | 4 字节   | +/-3.4E+38F（6~7 个有效位）                |
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |
| 字符型       | char    | 2 字节   | ISO 单一字符集                             |
| 布尔型       | boolean | 1 字节   | true 或 false                              |

# String相关

==String, StringBuffer，StringBuilder的区别？==
**由于String是不可变类，所以是线程安全的**，但是由于不可修改，所以每次修改都需要创建新的对象，比较浪费资源，所以引入StringBuffer，StringBuilder类，这两个类都是可变的
StringBuffer和StringBuilder类都是可变类，**但是StringBuffer是线程安全的，而StringBuilder是线程不安全的。**所以在多线程的环境下可以使用StringBuffer，但是效率和速度没有StringBuilder高
StringBuffer实现线程安全的方法是在内部方法上用synchronized关键字修饰，其实就是加锁。

# 如何将String转换为char,反过来呢？

- String不可能转化为char，但是可以转化为char数组
- 调用toCharArray() 方法

String.valueOf()或者 new 一个String 都可以把char转化为String

# 线程

1）继承Thread类创建线程

2）实现Runnable接口创建线程

==采用继承Thread类方式：==
（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。
（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。
==采用实现Runnable接口方式：==

> Thread thread = new Thread(new MyRunnable());
>
> class MyRunnable implements Runnable

（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，**较好地体现了面向对象的思想**。
（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。

==采用实现Callable接口方式：==

> Runable没有返回值，run()方法返回类型为void，Callable方法有返回值，call()方法返回类型为泛型和Future、FutureTask配合使用可以获取方法返回值；Callable的call()方法允许向上抛出异常，Runable的run()方法不允许向上抛出异常，只能在内部消化

## 1、线程的基本概念

##### 概念：

==线程是进程中执行运算的最小单位==，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，==同一进程中的多个线程之间可以并发执行。==

##### 好处 ：

（1）易于调度。 （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。 （3）开销少。创建线程比创建进程要快，所需开销很少。 （4）利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。 

## 2、进程的基本状态及状态之间的关系

##### 状态：运行、阻塞、挂起阻塞、就绪、挂起就绪

>  状态之间的转换：准备就绪的进程，被CPU调度执行，变成运行态； 运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态； 运行中的进程，进程执行完毕（或时间片已到），变成就绪态； 将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态； 将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态； 

## 3、线程和进程的关系以及区别？

##### 进程和线程的关系：

>  （1）==一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。== （2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 （3）处理机分给线程，即真正在处理机上运行的是线程。 （4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体. 

##### 进程与线程的区别：

>  （1）==调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位== （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. （4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。 

## 4、进程间通信的方式

>  （1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 
>
>  （2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。 
>
>  （3）消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。 
>
>  （4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 
>
>  （5）信号量（semaphore）：==主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段==
>
>  （6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 

## 5、同步和互斥的区别

**同步是互斥基础上对资源的有序访问**

>  当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，==由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。==为解决此问题，你必须使两个线程同步工作。 
>
>  所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，==同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。==在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 
>
>  所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

## 6、线程的生命周期

JDK中用Thread.State类定义了线程的几种状态

1. 新建：当一个Thread类或其子类的对象被声明并创建时，新的线程对象处于新建状态。
2. 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。
3. 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能。
4. 阻塞：在某种特殊情况下，被认为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态。
5. 死亡：线程完成了它的全部工作或线程被提前强制性的中止或出现异常倒置导致结束。

## 7、线程的安全性问题（多窗口售票）

三个窗口 1 2 3  还剩一张票

当 1 窗口 卖完票还没有把票数减一的时候（被阻塞），如果此时其他窗口也在卖票，这就会导致“多卖了票”。

### 7.1 同步代码块 synchronized

synchronized( 同步监视器 ) { 需要被同步的代码 }

```
synchronized (obj) {

}
```

### 7.2 同步方法 synchronized

```
public static synchronized void show()
```

### 7.3 Lock 锁

```
lock.lock();
finally {
			//操作完成共享数据后在这里解锁
			lock.unlock();
		}
```

## 8、 死锁

一个线程T1持有锁L1并且申请获得锁L2，而另一个线程T2持有锁L2并且申请获得锁L1，因为==默认的锁申请操作都是阻塞的==，所以线程T1和T2永远被阻塞了。

**线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，也就是说在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因**。另一个原因是**默认的锁申请操作是阻塞的**。

### 死锁出现的四个条件

互斥：一个资源在一段时间里只能被一个线程所有，若有其他进程请求该资源，则请求进程只能等待。

不剥夺：资源在一个线程还没有用完的时候不能被剥夺。

请求和保持：已经有资源的一个线程去请求其他资源，不仅自己被阻塞，资源也没有释放。

循环等待：链中每一个线程已获得的资源同时被链中下一个线程所请求。



# JDK>JRE>JVM

**jps**(Java Virtual Machine Process Status Tool) 是java提供的一个显示当前所有java进程pid的命令。

jinfo全称Java Configuration Info，所以它的主要作用是实时查看和调整JVM配置参数。

-----------

**jdk（javac）>jre（java）>jvm**

> JDK(Java Development Kit) 是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是JVM（Java Virtual Machine），lib中则是JVM工作所需要的类库，而JVM和 lib 合起来就称为JRE（Java Runtime Environment，Java运行环境）。

JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。==JVM+Lib=JRE。==总体来说就是，**我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。**

JRE 主要包含：

> java 类库的 class 文件(都在 lib 目录下打包成了 jar)和虚拟机(jvm.dll)；

JDK 主要包含：

> java 类库的 class文件(都在 lib 目录下打包成了 jar)==并自带一个 JRE==。那么为什么 JDK 要自带一个 JRE 呢？
>
> 而且 jdk/jre/bin 下的 client 和 server 两个文件夹下都包含 jvm.dll(说明 JDK 自带的 JRE 有两个虚拟机)。
>
> ==在安装JRE的时候，安装程序自动完成了java.exe解释命令的系统环境变量配置，这是为了方便那些不需要开发而只需要运行的非开发人员安装后直接就可以使用。==
>
> ==因为JDK里的很多开发工具命令都是用java写的==，所以在jdk目录下的jre是用来运行一般 Java 程序用的。



- 栈：基本类型的变量，对象的引用变量，实例对象的方法
- 堆：存放由new创建的对象和数组
- 方法区：Class对象，static变量，常量池（常量）

==JVM调优主要是针对 堆 区域的，一个JVM只有一个堆内存,堆内存的大小是可以调节的,类加载器读取类文件后,一般会把类,方法,常量,变量,我们所有引用类型的真实对象,放入堆中。==

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/watermark%252Ctype_ZmFuZ3poZW5naGVpdGk%252Cshadow_10%252Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjY1NzQ1%252Csize_16%252Ccolor_FFFFFF%252Ct_70-16608833365255.png)

## 类加载器双亲委派

向上委托 向下执行

![在这里插入图片描述](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/watermark%252Ctype_ZmFuZ3poZW5naGVpdGk%252Cshadow_10%252Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjY1NzQ1%252Csize_16%252Ccolor_FFFFFF%252Ct_70.png)

## 垃圾回收

引用计数

复制

标记清除

# ArrayList和LinkedList

1. ArrayList是实现了**基于动态数组**的数据结构，而LinkedList是**基于链表**的数据结构；
2. 对于**随机访问get和set，ArrayList要优于LinkedList**，因为LinkedList要移动指针；
3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList**并不能明确说明谁快谁慢。**
4. 插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣与ArrayList，且越靠近后面越差。

# HashMap

Jdk1.7：数组 + 链表 ( 当数组下标相同，则会在该下标下使用链表)
Jdk1.8：数组 + 链表 + 红黑树 (阈值为8 如果链表长度>=8则会把链表变成红黑树 )

每个红色结点的两个子节点必须是黑色的。换句话说：从每个叶子到根的所有路径上不能有两个连续的红色结点

从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

> 往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。（1.7）
> 1.8 加入红黑树，并且链表由头插改为尾插

==数组和链表==

==数组+链表+红黑树==

put方法被调用时，==HashMap会根据key计算出对应的hashcode==，然后根据hashcode确定该Entity应该存放在数组的哪个位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。

根据hashcode确定该Entity应该存放在数组的哪个位置（即下标）这种设定有一个问题：实际引用中有可能会发生hash碰撞（即两个数据虽然内容不同，但其hashcode有可能是相同的）！因此，HashMap如果发现hashcode已经存在，则会==对key进行euqals对比==：

equals结果是true，则认为确实是同一个key，然后将新的value覆盖旧的value（此时put方法将会返回旧value值）。
equals结果是false，则认为是hash碰撞，此时会将之前的Entity作为新Entity的next，此时形成一个链表，新Entity则处在链表的首位。

> ==Java中HashMap是利用“拉链法”处理HashCode的碰撞问题。==把HashCode相同的Value连成链表。

# 反射

JAVA 反射机制**是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性**；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

==Class.forName()传入类的路径获取==

==instance.getClass()==

==ClassLoader.LoadClass("cn.javaguide.TargetObject");==

1. 我们在使用 JDBC 连接数据库时使用 `Class.forName()`通过反射加载数据库的驱动程序；
2. Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；

# MySQL事务隔离级别

事务是一个不可分割的数据库操作序列,也是数据库并发控制的基本单位,其执行的结果将使数据库从一种一致性状态变迁到另一种一致性状态。事务是逻辑上的一组操作,**要么全部执行,要么全部不执行**。

==事务的四大特征==
1.原子性:事务是最小的执行单位,不允许分割。事务的原子性确保动作要么全部完成,要么完全不起作用

2.一致性:执行事务前后,数据保持一致,多个事务对同一个数据读取的结果是相同的。

3.隔离性:并发访问数据库时,一个用户的事务不被其他事务所干扰,各并发事务之间数据库是独立的

4.持久性:一个事务被提交之后。它对数据库中数据的改变是持久的,即使数据库发生故障也不应该对其有任何影响

==默认是可重复读==因为主从复制

![隔离级别](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/1629488-20190622123004301-566049444.png)

脏读：**一个事务读到另外一个事务还没有提交的数据**

幻读：==在一个事务的两次查询中数据不一致==,例如有一个事务查询了几列(RoW)数据,而另一个事务却在此时插入了新的几列数据,先前的事务在接下来的查询中,就会发现有几列数据是它先前所没有的。

不可重复读(Non- repeatable read)：**在一个事务**的两次查询之中数据不一致,这可能是两次查询过程中间插入了个事务更新的原有的数据。

------

# TCP三次握手 运输层

==请求，确认，连接==

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/70.png)

三次握手的目的是为了确认客户端和服务端的收发功能是正常的。

1.客户端的发送功能；
2.客户端的接收功能；
3.服务端的发送功能；
4.服务端的接收功能；

**第一次握手是客户端主动发起的**，当第一次握手的报文被送达服务端的时候，**服务端就知道自己的接收功能是完好的了**。服务器接收正常

第二次握手是服务器端发起的，这时候就可以知道**客户端的发送和接收功能都是正常的**。

第三次握手是客户端发起的，最后确定**服务器端的发送功能是正常的**。

能接收就说明接收功能正常；但是能发送不一定代表发送功能正常，发送功能需要通过**seq(写信)和ack(回信)**才能判断

# 重定向和请求转发

**转发是服务器行为，重定向是客户端行为。**

1. 从地址栏显示来说
    forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.

    redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

2. 从数据共享来说
    forward:转发页面和转发到的页面可以共享request里面的数据.
    redirect:不能共享数据.

3. 从运用地方来说
    forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
    redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等

4. 从效率来说
    forward:高.
    redirect:低.

# SSL

SSL加密是建立在非对称加密算法的基础上的。非对称加密算法会产生一对长字符串，**称为密钥对（公钥、私钥）**。数据使用公钥进行加密后，

唯一只能使用私钥才能解开。安装了服务器证书的网站，其实是==把私钥保存在服务器中，而把公钥连同网站相关信息（如：域名、所有者名称、有效期）制作成一张SSL证书，并把SSL证书公布到互联网==上。

当用户访问网站的时候能得到这张SSL证书，当用户提交数据时，客户端使用保护的公钥的SSL证书对数据进行加密。由于非对称加密必须使用私钥才能解密，那么在网络传输时，即使数据被截获，**由于截获者无法得到私钥，那么截获者也就无法破解密文**。因此建立在SSL加密的HTTPS协议才会被认为是安全的，HTTPS网站才会被Chrome等主流浏览器认为是安全的网站。

# 面向对象

封装（抽象）：对象是封装的最基本单位，把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。==私有的属性，公有的方法==。即**将对象封装成一个高度自治和相对封闭的个体**。

> 司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，**司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。**

继承：==继承是子类自动共享父类数据和方法的机制==，这是类之间的一种关系， 提高了软件的可重用性和可扩展性。

多态：==对于同一个行为，不同的子类对象具有不同的表现形式。==同一个事件发生在不同的对象上会产生不同的结果。

**面向对象和面向过程的异同点：**比如自己做菜和去饭店点菜的区别。

# 多态的实现方式

==方法的重载和重写都是实现多态的方式==，区别在于==重载实现的是编译时的多态性，而重写实现的是运行时的多态性。==

重载：一个类中有多个同名的方法，但是具有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。

重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。

# Error 和 Exception 有什么区别？

Error 和 Exception 都是 **Throwable** 的子类

==Error 表示系统级的错误和程序不必处理的异常==，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。

**Exception 表示需要捕捉或者需要程序进行处理的异常**，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。

# 编译和运行的区别

**编译时类型指在声明对象时所采用的类型**

**运行时类型指为对象赋值时所采用的类型**

1.编译就是将java代码交给编译器进行语法检查，如果没有错误就生成.class文件

2.运行就是将字节码文件(.class)交给java虚拟机执行，如果没有逻辑错误，就成功出现结果。

**编译期和运行期内存的分配**

1.编译期仅仅知道内存分配的位置和大小，不做具体的分配操作

2.运行期确定真正的分配，确定分配的大小以及位置

# InnoDB与MyISAM的区别

（1）事务：MyISAM不支持事务，**InnoDB支持事务。**

（2）锁级别：MyISAM只支持表级锁，**InnoDB支持行级锁和表级锁**，默认使用行级锁，但是行锁只有通过索引查询数据才会使用，否则将使用表锁。

（3）主键和外键：MyISAM 允许没有任何索引和主键的表存在，不支持外键。**InnoDB的主键不能为空且支持主键自增长**，如果没有设定主键或者非空唯一索引，就会**自动生成一个6字节的主键，支持外键完整性约束。**

（4）索引结构：MyISAM 和 InnoDB 都是使用B+树索引，MyISAM的主键索引和辅助索引的Data域都是保存行数据记录的地址。但是**InnoDB的主键索引的Data域保存的不是行数据记录的地址，而是保存该行的所有数据内容，而辅助索引的Data域保存的则是主索引的值。**

# InnoDB 行锁

- 共享锁（S锁、读锁）：多个事务可以对同一数据行共享一把S锁，但==只能进行读不能修改；==
- 排它锁（X锁、写锁）：一个事务获取排它锁之后，可以对锁定范围内的数据行执行写操作，在锁定期间，其他事务不能再获取这部分数据行的锁（共享锁、排它锁），只允许获取到排它锁的事务进行更新数据。

# == 和 equals 的区别是什么？

**一、对象类型不同**

1、equals()：是超类Object中的方法。

2、==：是操作符。

**二、比较的对象不同**

1、equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。

2、==：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：

（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。

（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。

**三、运行速度不同**

1、equals()：没有 == 运行速度快。

2、== 运行速度比equals()快，因为 == 只是比较引用。

总结：equals方法比较的是对象的值是否相等，而 == 比较的是引用是否相等，也就是说，如果当两个对象的值一样但是引用地址不一样的时候，用equals比较是true但是用 == 就是false。

补充：**Java有 5种引用类型（对象类型）：类 接口 数组 枚举 标注**

# 堆和栈

1 ==栈：为编译器自动分配和释放，如函数参数、局部变量、临时变量等等==
2 堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用new申请的堆内容。
3 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。

# Spring

MVC： **DispatcherServlet**、==请求拦截转发、处理器适配、视图解析返回==



# SpringBoot

- 独立运行
    Spring Boot 而且内嵌了各种 servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依赖包都在一个 jar 包内。
- **简化配置**
    **spring-boot-starter-web 启动器自动依赖其他组件，简少了 maven 的配置。**
- 自动配置
    ==Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean，如添加一个 spring-boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。==
- 无代码生成和XML配置
    Spring Boot 配置过程中无代码生成，也无需 XML 配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是 Spring4.x 的核心功能之一。
- 避免大量的Maven导入和各种版本冲突
- 应用监控
    Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。

启动：

运⾏带有 mian ⽅法类。
类 上 需 要 加 @SpringBootApplication 注 解 ， main ⽅ 法 中 使 ⽤
**SpringApplication.run(类名.class，args);⾃动加载 application.properties ⽂件。**



- **Spring**
    Spring最重要的特征是==依赖注入==。所有Spring Modules不是依赖注入就是IOC控制反转。
    当我们恰当的使用DI或者是IOC的时候，可以开发==松耦合==应用。

- **Spring MVC**
    Spring MVC提供了一种==分离式的方法来开发Web应用==。通过运用像DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。

- **SpringBoot**
    Spring和Spring MVC的问题在于需要配置大量的参数。
    SpringBoot通过一个自动配置和启动的项来解决这个问题。



- YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？

    1. 配置有序，在一些特殊的场景下，配置有序很关键
    2. 支持数组，数组中的元素可以是基本数据类型也可以是对象
    3. 简洁

- starter到底是什么 ?

    首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 `XXXAutoConfiguration` ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter

- spring-boot-starter-parent 主要有如下作用：

    1. 定义了 Java 编译版本为 1.8 。
    2. 使用 UTF-8 格式编码。
    3. 继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。
    4. 执行打包操作的配置。
    5. 自动化的资源过滤。
    6. 自动化的插件配置。
    7. 针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。



```java
spring-boot-starter-parent 	//boot 项目继承的父项目模块. 
spring-boot-starter-web 	//boot 项目集成 web 开发模块.
spring-boot-starter-tomcat  //boot 项目集成 tomcat 内嵌服务器. 
spring-boot-starter-test 	//boot 项目集成测试模块.
mybatis-spring-boot-starter //boot 项目集成 mybatis 框架.
spring-boot-starter-jdbc 	//boot 项目底层集成 jdbc 实现数据库操作支持.
其他诸多组件，可到 maven 中搜索，或第三方 starter 组件到 github 上查询
```

# Mybatis

**一级缓存和二级缓存**

- 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
- 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
    - 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据
- 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存

1：创建 SqlSessionFactory。

2：通过 SqlSessionFactory 创建 SqlSession。

3：通过 SqlSession 执行数据库操作。

4：调用 session.commit() 提交事务。

5：调用 session.close() 关闭会话。

![image-20220909000341251](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220909000341251.png)

# 数据库

第一：列不可再分，原子性

第二：属性完全依赖主键

第三：非主键列之间不存在依赖关系

## 三级模式、两层映像

数据库系统的三级模式是指用户模式、概念模式和存储模式。（也称**外模式、概念模式、内模式**）

**两个独立性**
**逻辑数据独立性**
当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序
**物理数据独立性**
当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式
==外模式到概念模式的映像实现了数据的逻辑独立性。
概念模式到内模式的映像实现了数据的物理独立性。==

# 大数据案例demo

**使用爬虫等获取实时数据+Flume+Kafka+Spark S**

**streaming+mysql+Echarts实现数据动态实时采集、分析、展示**

主要工作流程如下：

其中爬虫获取实时数据，并把数据**实时传输到Linux本地文件夹**中。

使用Flume**实时监控**该文件夹，如果发现文件内容变动则进行处理，将**数据抓取并传递到Kafka消息队列**中。

之后**使用Spark Streaming 实时处理Kafka通道中的数据**，并写入本地mysql数据库中，之后**读取mysql数据库中的数据并基于Echart折线图对数据进行实时动态展示。**

![image-20220318161438182](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220318161438182.png)



# Shiro

![image-20220908223700363](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223700363-16626479264873.png)

![image-20220908223715292](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223715292-16626479179041.png)



![image-20220908223919619](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223919619.png)

![image-20220908223738786](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223738786.png)

# SpringSecurity 原理

用于认证、授权。==基本原理就是应用了Tomcat容器的Filter==，其的实现原理也就是类似于Tomcat本身的ApplicationFilterChain，也就是Filter执行链。先执行Tomcat自身已有的Filter，然后再交给SpringSecurity定义的FilterChainProxy，然后其再去执行SpringSecurity用于认证、授权管理的各种Filter。这个就是SpringSecurity的核心原理。

# SSO

在 B/S 系统中，登录功能通常都是基于 Cookie 来实现的。当用户登录成功后，一般会将登录状态记录到 Session 中，或者是给用户签发一个 Token，无论哪一种方式，都需要在客户端保存一些信息（Session ID 或 Token ），并要求客户端在之后的每次请求中携带它们。在这样的场景下，使用 Cookie 无疑是最方便的，因此我们一般都会将 Session 的 ID 或 Token 保存到 Cookie 中，当服务端收到请求后，通过验证 Cookie 中的信息来判断用户是否登录 。

==单点登录（Single Sign On, SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。==举例来说，百度贴吧和百度地图是百度公司旗下的两个不同的应用系统，如果用户在百度贴吧登录过之后，当他访问百度地图时无需再次登录，那么就说明百度贴吧和百度地图之间实现了单点登录。

单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。当然仅此是不够的，因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 Session ID 是往往保存在浏览器 Cookie 中的。

**我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。**

**用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）**

**应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。**

# Redis

expire key time 设置过期时间

大数据时代三V：海量Volume、多样Variety、实时Velocity

大数据时代三高：高并发、高可用（无限套娃+彼此监控）、高性能

```bash
- Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
# 默认有16个数据库 使用select切换
-----------------------------------
set get flushall flushdb 
```

![image-20220908223220109](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223220109.png)

redis可以用作**数据库、缓存和消息中间件**。

```bash 
keys * 查看所有key
exists 返回 0 / 1
move name 1 删除
expire [name] [时长] 设置过期时间
type 查看类型 
秒语法：ttl key 毫秒语法：pttl key 查询key的生命周期（秒）

设置过期时间
秒语法：expire key seconds
毫秒语法：pexpire key milliseconds

设置永不过期
语法：persist key

更改键名称
语法：rename key newkey

值递增/递减
如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错。
语法：incr key

追加内容
语法：append key value

获取值长度
语法：strlen key

获取部分字符
语法：getrange key start end

设置过期时间
setex key [时长] [name]

获取并设置值
getset
```



## redis持久化

RDB快照（snapshotting）

把当前内存中的数据集**快照**写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。

可以自动触发（关机触发、隔一段时间触发）也可以手动触发（save和bgsave）。**Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。**

==恢复==：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。

----------

AOF（append-only-file）

默认不开启，默认使用的是RDB

**通过保存Redis服务器所执行的【写命令】来记录数据库状态**

![image-20220908223504692](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223504692.png)

RDB 持久化方式就是将 str1,str2,str3 这三个键值对保存到 RDB文件中，而 AOF 持久化则是将执行的 set,sadd,lpush 三个命令保存到 AOF 文件中。

AOF 文件恢复：

　　重启 Redis 之后就会进行 AOF 文件的载入。

　　异常修复命令：redis-check-aof --fix 进行修复

AOF 重写：

　　由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重新。

## redis发布订阅

发布者和订阅者都是Redis客户端，==Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息==。Redis的这种发布订阅机制与基于主题的发布订阅类似，Channel相当于主题。简单来说和**对讲机**的意思差不多。

## redis主从复制

![image-20220809213718293](面试题【。。。】.assets/image-20220809213718293.png)

主节点写、从节点读。

![image-20220908223517469](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223517469.png)

## redis哨兵模式

监控主机故障，自动选举老大的模式

![image-20220809214349850](面试题【。。。】.assets/image-20220809214349850.png)

![image-20220908223537551](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223537551.png)

## redis缓存穿透

![image-20220908223632394](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908223632394.png)

## redis缓存击穿

正在疯狂查询的某数据过期了，导致去大量查询持久层数据库。

![image-20220809220139047](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220809220139047.png)

## redis缓存雪崩

缓存集中失效，或者redis宕机。

限流降级：通过加锁来控制线程数或者停掉一些不必要的服务，保证主服务的运行。

高可用：多增设几台redis

数据预热：把在未来可能会频繁访问的数据人为提前加载到缓存里。

# Kafka

Kafka是分布式发布-订阅消息系统 采用pull模式，消费者可以根据消费能力自主确定需要的资源。

缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。

一个`topic`可以被 **多个消费者组**消费，但是每个消费者组消费的数据是 **互不干扰** 的，也就是说，每个消费者组消费的都是 **完整的数据**。

![image-20220908234350353](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220908234350353.png)

# Flume

实时日志收集系统

![image-20220907114857629](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220907114857629.png)

Source是数据的收集端，负责将数据捕获后进行特殊的格式化，将数据封装到事件（event） 里，然后将事件推入Channel中。

Channel是连接Source和Sink的组件，大家可以将它看做一个数据的缓冲区（数据队列），它可以将事件暂存到内存中也可以持久化到本地磁盘上

Sink从Channel中取出事件，然后将数据发到别处，可以向文件系统、数据库、 hadoop存数据

# Zookeeper

ZooKeeper主要**服务于分布式系统**，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。

# UUID

UUID 是由一组32位数的16进制数字所构成.

Universally Unique Identifier，翻译为中文是**通用唯一识别码**，UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息。

# Spark

**我们使用spark-submit提交一个Spark作业之后，这个作业就会启动一个对应的Driver进程。**根据你使用的部署模式（deploy-mode）不同，Driver进程可能在本地启动，也可能在集群中某个工作节点上启动。**而Driver进程要做的第一件事情，就是向集群管理器**（可以是Spark Standalone集群，也可以是其他的资源管理集群，美团•大众点评使用的是YARN作为资源管理集群）**申请运行Spark作业需要使用的资源**，这里的资源指的就是Executor进程。YARN集群管理器会根据我们为Spark作业设置的资源参数，**在各个工作节点上，启动一定数量的Executor进程，每个Executor进程都占有一定数量的内存和CPU core。**
　　在申请到了作业执行所需的资源之后，Driver进程就会开始调度和执行我们编写的作业代码了。Driver进程会将我们编写的Spark作业代码分拆为多个stage，每个stage执行一部分代码片段，并为每个stage创建一批Task，然后将这些Task分配到各个Executor进程中执行。Task是最小的计算单元，负责执行一模一样的计算逻辑（也就是我们自己编写的某个代码片段），只是每个Task处理的数据不同而已。**一个stage的所有Task都执行完毕之后，会在各个节点本地的磁盘文件中写入计算中间结果，然后Driver就会调度运行下一个stage。下一个stage的Task的输入数据就是上一个stage输出的中间结果。如此循环往复，直到将我们自己编写的代码逻辑全部执行完，并且计算完所有的数据，得到我们想要的结果为止。**

# 秒杀

## 1 秒杀业务特点

瞬时并发量大：秒杀时会有大量用户在同一时间进行抢购，瞬时并发访问量突增 10 倍，甚至 100 倍以上都有。

库存量少：一般秒杀活动商品量很少，这就导致了只有极少量用户能成功购买到。

业务简单：流程比较简单，一般都是下订单、扣库存、支付订单。

## 2 技术难点

现有业务的冲击：秒杀是营销活动中的一种，如果和其他营销活动应用部署在同一服务器上，肯定会对现有其他活动造成冲击，极端情况下可能导致整个电商系统服务宕机。

直接下订单：下单页面是一个正常的 URL 地址，需要控制在秒杀开始前，不能下订单，只能浏览对应活动商品的信息。简单来说，需要 Disable 订单按钮。

页面流量突增：秒杀活动开始前后，会有很多用户请求对应商品页面，会造成后台服务器的流量突增，同时对应的网络带宽增加，需要控制商品页面的流量不会对后台服务器、DB、Redis 等组件的造成过大的压力

## 3 架构设计思想

==限流==：由于活动库存量一般都是很少，对应的只有少部分用户才能秒杀成功。所以我们需要限制大部分用户流量，只准少量用户流量进入后端服务器。

==削峰==：秒杀开始的那一瞬间，会有大量用户冲击进来，所以在开始时候会有一个瞬间流量峰值。如何把瞬间的流量峰值变得更平缓，是能否成功设计好秒杀系统的关键因素。实现流量削峰填谷，一般的采用缓存和MQ中间件来解决。

异步：秒杀其实可以当做高并发系统来处理，在这个时候，可以考虑从业务上做兼容，将同步的业务，设计成异步处理的任务，提高网站的整体可用性。

缓存：秒杀系统的瓶颈主要体现在下订单、扣减库存流程中。在这些流程中主要用到 OLTP 的数据库，类似 MySQL、 SQLServer、Oracle。由于数据库底层采用 B+ 树的储存结构，对应我们随机写入与读取的效率，相对较低。如果我们把部分业务逻辑迁移到内存的缓存或者 Redis 中，会极大的提高并发效率。

## 4 总结

秒杀系统核心在于层层过滤，逐渐递减瞬时访问压力，减少最终对数据库的冲击。通过上面流程图就会发现压力最大的地方在哪里？

MQ 排队服务，只要 MQ 排队服务顶住，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的压力，可以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。

库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时通过超时处理任务发现已抢到商品，但未付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存量。整体架构如下图所示：

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/2090080-20220520193517119-876103270.png)

# 锁 synchronized

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/webp.webp)

# 线程池

Java通过**Executors**提供四种线程池 

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

1.newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

2.通过调用Executors类的静态newCachedThreadPool()方法可以获得缓存的线程池。

语法：ExecutorService executor = Executors.newCachedThreadPool();

> **线程池的作用：**
>
> ==线程池作用就是限制系统中执行线程的数量。==
>    根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。
>
> **为什么要用线程池:**
>
> 1.减少了创建和销毁线程的次数，==每个工作线程都可以被重复利用，可执行多个任务。==
>
> 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，==防止因为消耗过多的内存==，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
>
> Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。

# Docker

概念：Docker 是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。==它使用容器来打包应用程序及其依赖项。==我们也可以将容器视为 Docker 镜像的运行时实例。

Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。==Docker 使用 Dockerfile 中的指令自动构建镜像。==我们可以 `docker build` 用来创建按顺序执行多个命令行指令的自动构建。

**常用命令**

1. 查看本地主机的所用镜像：`docker images`
2. 搜索镜像：`docker search mysql`
3. 下载镜像：`docker pull mysql`，没写 tag 就默认下载最新的 lastest
4. 下载指定版本的镜像：`docker pull mysql:5.7`
5. 删除镜像：`docker rmi -f 镜像id 镜像id 镜像id`

---------

# Nginx和代理

什么是正向代理和反向代理？
正向代理就是一个人发送一个请求直接就到达了目标的服务器。
==反向代理就是请求统一被Nginx接收，nginx反向代理服务器接收到之后，按照一定的规 则分发给了后端的业务处理服务器进行处理了。==

- ==跨平台==：可以在大多数Unix like 系统编译运行。而且也有Windows的移植版本。
- 配置异常简单：非常的简单，易上手。
- 非阻塞、高并发连接：数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能支持5万并发连接，实际生产中能跑2~3万并发连接数（得益于Nginx采用了最新的epoll事件处理模型（消息队列）。
- Nginx代理和后端Web服务器间无需长连接；
- ==Nginx接收用户请求是异步的，即先将用户请求全部接收下来，再一次性发送到后端Web服务器，==极大减轻后端Web服务器的压力。
- 发送响应报文时，是边接收来自后端Web服务器的数据，边发送给客户端。
- 网络依赖性低，理论上只要能够ping通就可以实施负载均衡，而且可以有效区分内网、外网流量。
- 支持内置服务器检测。Nginx能够根据应用服务器处理页面返回的状态码、超时信息等检测服务器是否出现故障，并及时返回错误的请求重新提交到其它节点上。
- 此外还有内存消耗小、成本低廉（比F5硬件负载均衡器廉价太多）、节省带宽、稳定性高等特点。

------

# 怎么处理高并发

1、优化代码，减少不必要的资源浪费。比如避免频繁的new对象，可以用单例模式。使用StringBuffer或者StringBuilder（线程不安全）等。工具类使用静态访问方式。

2、html页面静态化

3、图片和主服务器分离，使用独立服务器加载。

4、缓存

5、优化sql语句   a.Select语句指定列名   b.当查询结果为一条时，使用limit 1

# get和post的区别

GET请求会被浏览器主动cache，而POST不会。

GET请求在URL中传送的参数是有长度限制的，而POST没有。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。

# TCP/IP模型

![TCP/IP模型](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/v2-235a19c3581bfaed84fa11f57857ba1c_1440w.jpg)

**1、应用层：http，ftp。**

文件传输（FTP)：文件传输是指将其它计算机磁盘上的文件转移到本地计算机上，或将本地磁盘上的文件传送到其它计算机磁盘上。该文件传输过程使用的协议叫做FTP协议。在FTP中进行文件传输时会建立两个TCP连接，分别是发送传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接。

DNS协议：主要功能是通过用户友好的名称为用户提供域名解析服务，即将主机名域名解析为IP地址。

HTTP协议：超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则。

SMTP协议：Simple Mail Transfer Protocol（简单邮件传输协议）。

**2、传输层：TCP和UDP协议**

UDP协议（User Datagram Protocol，用户数据报协议）是一种不可靠无连接的传输层协议，不考虑流控制、错误控制，没有重传机制，不会对分组进行顺序检查和排序。（UDP报头含8字节定长和2字节倍数的数据<不是2字节倍数时需要填充位>）

TCP协议（Transport Control Protocol，传输控制协议）是一种面向连接、可靠的、基于字节流的传输层协议，采用了确认机制、超时重传机制，还会对接收到的TCP报文段进行重新排列整理。（TCP报头含20字节定长、选项和填充<选项和填充小于等于40字节>）

**3、网络层：IP协议**

IP协议：Internetworking Protocol（网间网协议），IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP也是分组交换的一种协议，但是它不具备重发机制，因此它是不可靠传输协议。

IPv4：头部由20字节定长和一个可选的变长部分（小于等于40字节）组成，32位记录源端IP地址，32位记录目的端IP地址，所有内容长度最大为2^16=65476字节。

IPv6：头部由40字节定长组成。128位记录源端IP地址，128位记录目的端IP地址。

**4、链路层：**用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动和网络适配器，及光纤等物理可见的部分。硬件上的范畴均属于链路层的作用范围之内。这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。

> 把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。
