我是石家庄铁道大学2023届软件工程系的学生，希望可以在贵公司参加实习工作，请您过目我的简历。

**个人简介：**

博客园：https://www.cnblogs.com/rainbow-1/
Github：https://github.com/SAH01?tab=repositories
Gitee ： https://gitee.com/yang-chuanwei/projects

个人主页：https://www.reliableyang.cn/



------

# 面试相关

**后端：**

1. 熟悉Java面向对象思想以及JVM，如垃圾回收、内存等；对Java并发和网络编程、线程有一定认识
2. 掌握SpringMVC、SpringBoot，熟悉源码和其设计思想比如IOC和AOP原理，事务原理，MVC工作流程等
3. 掌握MySQL数据库（事务锁、数据类型和表结构、索引、SQL语句等有自己的理解

**前端：**熟悉基本前端开发技术，如html+css+js+ajax以及echarts、layui等框架组件

**运维：**

1. 掌握git，使用github托管代码
2. 熟悉linux常见命令如kill、pwd、cat、vim等等，对其设计思想有一定认识
3. 熟悉redis，如主从复制，哨兵模式等
4. 熟悉软件测试基础，如黑盒白盒、Postman、Loadrunner、Selenium等

**其他：**

1. 对大数据相关有一定了解，如分布式计算、集群管理等；曾独立完成爬虫获取数据+Flume+Kafka+SparkStreaming+mysql+Echarts实现数据实时采集、分析和展示
2. 对系统架构设计有自己的理解，能够使用“分而治之”的思想解决实际问题
3. 有良好的规范代码编写习惯，有分析源码和重视业务逻辑的习惯；善于回顾总结经验错误，有记录博客和写文档的习惯。有一定的安卓开发和机器学习开发经验。

-----

- **计算机基础**：掌握计算机网络、操作系统、数据库原理、数据结构和算法，熟悉计算机组成原理
- **Linux**：熟练使用Linux，有Linux环境下的开发经验。
- **Java**：熟练掌握Java基础知识，如JVM、并发、网络编程、多线程等；有很好的排错和调试BUG能力。
- **数据库**：熟练掌握MySQL数据库及其常见优化方法（事务、索引、读写分离、分库分表设计）；熟悉列存储数据库Hbase、文档型存储数据库MongoDB
- **框架**：熟练掌握SSM、SpringBoot、MyBatis、Spring  Security；对其源码和底层逻辑有一定的理解（AOP、IOC等）。
- **高并发和高可用中间件**：掌握消息队列Kafka（限流，降级等）、实时日志收集Flume、缓存Redis（主从复制，哨兵模式等）
- **工具**：熟练掌握Maven、Git、Docker
- **前端**：熟悉基础Html+Css+JavaScript开发，有Vue开发经验；能熟练使用如Layui、BootStrap等组件。
- **其他**：熟悉软件测试技术（黑盒白盒、Postman、Loadrunner、Selenium等）;有ZooKeeper、Hadoop、Spark使用经验

--------

基于知识图谱的科技政策管理系统

**开发环境**：IDEA、JDK1.8、Git

**软件架构**：SpringBoot+Redis+Shiro+MySQL+Neo4j

**项目角色**：Java后端开发

**项目描述**：系统提供了完善的科技政策管理体系。通过参考现有的文本自动分类算法，使其能够完成科技政策的自动分类。提取科技政策的各种信息，完成多种条件相结合的检索方法。使用新词发现算法建立了科技政策的词典，同时配合文本分析算法，在一定程度上完成了科技政策之间的对比。采集大量科技政策建立有关科技政策的知识库，构成知识图谱，让政策与政策之间形成一定的关联。参考国务院发布的主题词表，确认了科技政策表达的主体内容。

**技术概述**：系统采用SpringBoot框架搭建，使用Shiro进行用户权限管理，实现单点登录，提高系统安全性。Redis统一缓存处理，提高系统性能和用户满意度，Hanlp文本处理并构建科技政策知识图谱网络图。该项目河北省科学技术情报研究院已投入使用。

**项目职责**：

1. 参与需求分析和系统设计的讨论工作，协助完成相关开发辅助文档。
2. 独立完成项目政策信息录入、政策主体标引管理模块的后台接口。
3. 负责部分分词统计和构建知识图谱的工作。
4. 负责项目上线部署调试和维护的工作。

- **Github：**https://github.com/SAH01/science_technology_policy_integration_service

----

个人博客系统

**开发环境**：IDEA、JDK1.8、Git

**软件架构**：SpringBoot+Redis+Vue+Spring  Security+MySQL+Vue

**项目角色**：Java后端开发

**项目描述**：项目主要提供包含但不限于写文章、标签管理、分类管理、最新最热文章、评论和归档等一系列功能模块，基本可以满足一个个人博客的使用需求。

**技术概述**：jwt + redis 使用token令牌登录，ThreadLocal本地保存用户信息并做了线程安全处理，文章加载和阅读数更新做了线程隔离处理，Spring  Security权限管理系统，统一日志记录、统一缓存处理、统一异常拦截、统一登录拦截，分布式ID（UUID）。

**项目职责**：负责全部的后端开发工作和部分前端工作。



-------





准备亚信科技面试

# 8种基本数据类型

![image-20220818215400709](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220818215400709.png)

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |
| ------------ | ------- | -------- | ------------------------------------------ |
| 字节型       | byte    | 1 字节   | -128~127                                   |
| 短整型       | short   | 2 字节   | -32768~32767                               |
| 整型         | int     | 4 字节   | -2147483648~2147483647                     |
| 长整型       | long    | 8 字节   | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float   | 4 字节   | +/-3.4E+38F（6~7 个有效位）                |
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |
| 字符型       | char    | 2 字节   | ISO 单一字符集                             |
| 布尔型       | boolean | 1 字节   | true 或 false                              |

# String相关

String, StringBuffer，StringBuilder的区别？
**由于String是不可变类，所以是线程安全的**，但是由于不可修改，所以每次修改都需要创建新的对象，比较浪费资源，所以引入StringBuffer，StringBuilder类，这两个类都是可变的
StringBuffer和StringBuilder类都是可变类，**但是StringBuffer是线程安全的，而StringBuilder是线程不安全的。**所以在多线程的环境下可以使用StringBuffer，但是效率和速度没有StringBuilder高
StringBuffer实现线程安全的方法是在内部方法上用synchronized关键字修饰，其实就是加锁。

# 如何将String转换为char,反过来呢？

- String不可能转化为char，但是可以转化为char数组
- 调用toCharArray() 方法

String.valueOf()或者 new 一个String 都可以把char转化为String

# 线程

1）继承Thread类创建线程

2）实现Runnable接口创建线程

==采用继承Thread类方式：==
（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。
（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。
==采用实现Runnable接口方式：==
（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，**较好地体现了面向对象的思想**。
（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。

> Runable没有返回值，run()方法返回类型为void，Callable方法有返回值，call()方法返回类型为泛型和Future、FutureTask配合使用可以获取方法返回值；Callable的call()方法允许向上抛出异常，Runable的run()方法不允许向上抛出异常，只能在内部消化

# JVM

**jdk（javac）>jre（java）>jvm**

JDK(Java Development Kit) 是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是JVM（Java Virtual Machine），lib中则是JVM工作所需要的类库，而JVM和 lib合起来就称为JRE（Java Runtime Environment，Java运行环境）。

JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，**我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。**

- 栈：基本类型的变量，对象的引用变量，实例对象的方法
- 堆：存放由new创建的对象和数组
- 方法区：Class对象，static变量，常量池（常量）

==JVM调优主要是针对 堆 区域的，一个JVM只有一个堆内存,堆内存的大小是可以调节的,类加载器读取类文件后,一般会把类,方法,常量,变量,我们所有引用类型的真实对象,放入堆中。==

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/watermark%252Ctype_ZmFuZ3poZW5naGVpdGk%252Cshadow_10%252Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjY1NzQ1%252Csize_16%252Ccolor_FFFFFF%252Ct_70-16608833365255.png)

## 类加载器双亲委派

![在这里插入图片描述](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/watermark%252Ctype_ZmFuZ3poZW5naGVpdGk%252Cshadow_10%252Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjY1NzQ1%252Csize_16%252Ccolor_FFFFFF%252Ct_70.png)

## 垃圾回收

引用计数

复制

标记清除

# ArrayList和LinkedList

1. ArrayList是实现了**基于动态数组**的数据结构，而LinkedList是**基于链表**的数据结构；
2. 对于**随机访问get和set，ArrayList要优于LinkedList**，因为LinkedList要移动指针；
3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList**并不能明确说明谁快谁慢。**
4. 插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣与ArrayList，且越靠近后面越差。

​	

# HashMap

Jdk1.7：数组 + 链表 ( 当数组下标相同，则会在该下标下使用链表)
Jdk1.8：数组 + 链表 + 红黑树 (阈值为8 如果链表长度>=8则会把链表变成红黑树 )

每个红色结点的两个子节点必须是黑色的。换句话说：从每个叶子到根的所有路径上不能有两个连续的红色结点

从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

> 往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。（1.7）
> 1.8 加入红黑树，并且链表由头插改为尾插

# 反射

JAVA 反射机制**是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性**；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

`Class.forName()`传入类的路径获取

 instance.getClass()

 ClassLoader.LoadClass("cn.javaguide.TargetObject");

1. 我们在使用 JDBC 连接数据库时使用 `Class.forName()`通过反射加载数据库的驱动程序；
2. Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；

# MySQL事务隔离级别

事务是一个不可分割的数据库操作序列,也是数据库并发控制的基本单位,其执行的结果将使数据库从一种一致性状态变迁到另一种一致性状态。事务是逻辑上的一组操作,**要么全部执行,要么全部不执行**。

事务的四大特征
1.原子性:事务是最小的执行单位,不允许分割。事务的原子性确保动作要么全部完成,要么完全不起作用

2.一致性:执行事务前后,数据保持一致,多个事务对同一个数据读取的结果是相同的。

3.隔离性:并发访问数据库时,一个用户的事务不被其他事务所干扰,各并发事务之间数据库是独立的

4.持久性:一个事务被提交之后。它对数据库中数据的改变是持久的,即使数据库发生故障也不应该对其有任何影响

==默认是可重复读==

![隔离级别](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/1629488-20190622123004301-566049444.png)

脏读：**一个事务读到另外一个事务还没有提交的数据**

幻读：在一个事务的两次查询中数据不一致,例如有一个事务查询了几列(RoW)数据,而另一个事务却在此时插入了新的几列数据,先前的事务在接下来的查询中,就会发现有几列数据是它先前所没有的。

不可重复读(Non- repeatable read)：**在一个事务**的两次查询之中数据不一致,这可能是两次查询过程中间插入了个事务更新的原有的数据。

------

# 三次握手 运输层

![img](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/70.png)

三次握手的目的是为了确认客户端和服务端的收发功能是正常的。

1.客户端的发送功能；
2.客户端的接收功能；
3.服务端的发送功能；
4.服务端的接收功能；

**第一次握手是客户端主动发起的**，当第一次握手的报文被送达服务端的时候，**服务端就知道自己的接收功能是完好的了**。服务器接收正常

第二次握手是服务器端发起的，这时候就可以知道**客户端的发送和接收功能都是正常的**。

第三次握手是客户端发起的，最后确定**服务器端的发送功能是正常的**。

能接收就说明接收功能正常；但是能发送不一定代表发送功能正常，发送功能需要通过**seq(写信)和ack(回信)**才能判断

# 重定向和请求转发

转发是服务器行为，重定向是客户端行为。

1. 从地址栏显示来说
    forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.

    redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

2. 从数据共享来说
    forward:转发页面和转发到的页面可以共享request里面的数据.
    redirect:不能共享数据.

3. 从运用地方来说
    forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
    redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等

4. 从效率来说
    forward:高.
    redirect:低.

# SSL

SSL加密是建立在非对称加密算法的基础上的。非对称加密算法会产生一对长字符串，**称为密钥对（公钥、私钥）**。数据使用公钥进行加密后，

唯一只能使用私钥才能解开。安装了服务器证书的网站，其实是把私钥保存在服务器中，而把公钥连同网站相关信息（如：域名、所有者名称、有效期）制作成一张SSL证书，并把SSL证书公布到互联网上。

当用户访问网站的时候边能得到这张SSL证书，当用户提交数据时，客户端使用保护的公钥的SSL证书对数据进行加密。由于非对称加密必须使用私钥才能解密，那么在网络传输时，即使数据被截获，**由于截获者无法得到私钥，那么截获者也就无法破解密文**。因此建立在SSL加密的HTTPS协议才会被认为是安全的，HTTPS网站才会被Chrome等主流浏览器认为是安全的网站。

# 面向对象

封装（抽象）：对象是封装的最基本单位，把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。私有的属性，公有的方法。即**将对象封装成一个高度自治和相对封闭的个体**。

> 司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，**司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。**

继承：继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系， 提高了软件的可重用性和可扩展性。

多态：对于同一个行为，不同的子类对象具有不同的表现形式。同一个事件发生在不同的对象上会产生不同的结果。

**面向对象和面向过程的异同点：**举例吃菜

# 多态的实现方式

方法的重载和重写都是实现多态的方式，区别在于重载实现的是编译时的多态性，而重写实现的是运行时的多态性。

重载：一个类中有多个同名的方法，但是具有有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。

重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。

# Error 和 Exception 有什么区别？

Error 和 Exception 都是 Throwable 的子类

Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。

**Exception 表示需要捕捉或者需要程序进行处理的异常**，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。

# 编译和运行的区别

**编译时类型指在声明对象时所采用的类型**

**运行时类型指为对象赋值时所采用的类型**

1.编译就是将java代码交给编译器进行语法检查，如果没有错误就生成.class文件

2.运行就是将字节码文件(.class)交给java虚拟机执行，如果没有逻辑错误，就成功出现结果。

**编译期和运行期内存的分配**

1.编译期仅仅知道内存分配的位置和大小，不做具体的分配操作

2.运行期确定真正的分配，确定分配的大小以及位置

# InnoDB与MyISAM的区别

（1）事务：MyISAM不支持事务，**InnoDB支持事务。**

（2）锁级别：MyISAM只支持表级锁，**InnoDB支持行级锁和表级锁**，默认使用行级锁，但是行锁只有通过索引查询数据才会使用，否则将使用表锁。

（3）主键和外键：MyISAM 允许没有任何索引和主键的表存在，不支持外键。**InnoDB的主键不能为空且支持主键自增长**，如果没有设定主键或者非空唯一索引，就会**自动生成一个6字节的主键，支持外键完整性约束。**

（4）索引结构：MyISAM 和 InnoDB 都是使用B+树索引，MyISAM的主键索引和辅助索引的Data域都是保存行数据记录的地址。但是**InnoDB的主键索引的Data域保存的不是行数据记录的地址，而是保存该行的所有数据内容，而辅助索引的Data域保存的则是主索引的值。**

# InnoDB 行锁

- 共享锁（S锁、读锁）：多个事务可以对同一数据行共享一把S锁，但只能进行读不能修改；
- 排它锁（X锁、写锁）：一个事务获取排它锁之后，可以对锁定范围内的数据行执行写操作，在锁定期间，其他事务不能再获取这部分数据行的锁（共享锁、排它锁），只允许获取到排它锁的事务进行更新数据。

# == 和 equals 的区别是什么？

**一、对象类型不同**

1、equals()：是超类Object中的方法。

2、==：是操作符。

**二、比较的对象不同**

1、equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。

2、==：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：

（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。

（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。

**三、运行速度不同**

1、equals()：没有 == 运行速度快。

2、== 运行速度比equals()快，因为 == 只是比较引用。

总结：equals方法比较的是对象的值是否相等，而 == 比较的是引用是否相等，也就是说，如果当两个对象的值一样但是引用地址不一样的时候，用equals比较是true但是用 == 就是false。

补充：**Java有 5种引用类型（对象类型）：类 接口 数组 枚举 标注**

# 堆和栈

1 栈：为编译器自动分配和释放，如函数参数、局部变量、临时变量等等
2 堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用new申请的堆内容。
3 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。

# Spring SpringMVC

**DispatcherServlet**、请求拦截转发、处理器适配、视图解析返回

# SpringBoot

**提供了各种启动器，开发者能快速上手**，所以 SpringBoot 是⼀个服务于框架的框架，服务范围是简化配置⽂件。Spring Boot 优点，如：（1）独立运行（2）简化配置（3）自动配置（4）无代码生成和 XML 配置（5）应用监控（6） 上手容易

启动：

运⾏带有 mian ⽅法类。
类 上 需 要 加 @SpringBootApplication 注 解 ， main ⽅ 法 中 使 ⽤
**SpringApplication.run(类名.class，args);⾃动加载 application.properties ⽂件。**

常见组件

```java
spring-boot-starter-parent 	//boot 项目继承的父项目模块. 
spring-boot-starter-web 	//boot 项目集成 web 开发模块.
spring-boot-starter-tomcat  //boot 项目集成 tomcat 内嵌服务器. 
spring-boot-starter-test 	//boot 项目集成测试模块.
mybatis-spring-boot-starter //boot 项目集成 mybatis 框架.
spring-boot-starter-jdbc 	//boot 项目底层集成 jdbc 实现数据库操作支持.
其他诸多组件，可到 maven 中搜索，或第三方 starter 组件到 github 上查询
```



# 数据库

第一：列不可再分，原子性

第二：属性完全依赖主键

第三：非主键列之间不存在依赖关系

## 三级模式、两层映像

数据库系统的三级模式是指用户模式、概念模式和存储模式。（也称**外模式、概念模式、内模式**）

**两个独立性**
**逻辑数据独立性**
当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序
**物理数据独立性**
当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式
==外模式到概念模式的映像实现了数据的逻辑独立性。
概念模式到内模式的映像实现了数据的物理独立性。==

# 大数据

**使用爬虫等获取实时数据+Flume+Kafka+Spark Streaming+mysql+Echarts实现数据动态实时采集、分析、展示**

主要工作流程如下：

其中爬虫获取实时数据，并把数据**实时传输到Linux本地文件夹**中。

使用Flume**实时监控**该文件夹，如果发现文件内容变动则进行处理，将**数据抓取并传递到Kafka消息队列**中。

之后**使用Spark Streaming 实时处理Kafka通道中的数据**，并写入本地mysql数据库中，之后**读取mysql数据库中的数据并基于Echart图表对数据进行实时动态展示。**

![image-20220318161438182](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20220318161438182.png)

-----



# 面试

https://www.reliableyang.cn/

面试官您好，我是来自石家庄铁道大学软件工程系的学生杨传伟，很荣幸来参加此次面试。下面简单做下自我介绍，我来自河北邯郸，下半年升大四。在校期间我担任学院的主持人完成了大小多个活动的主持和策划工作，这培养了我良好的语言表达能力。学习上多次获得奖学金，专业排名前列，简历中有我的一些获奖信息。专业技术上，擅长Java语言，基础知识比较扎实。有良好的规范编码意识和习惯，擅长撰写文档，在博客园坚持记录博客，发布500多篇十几万阅读。参与过老师的实际项目，也自己写了几个项目并以第一著作权人申请下了软著。 好奇心强，追求新技术，能够独立学习善于总结回顾。

**缺点**：可能有时候会性急一点，这一点如果利用好可能对克服困难有一定的帮助，我在努力调整。

**加班**：不反感加班，但是更喜欢高效完成任务，避免不必要的加班。

**规划**：希望首先从技术从底层入手，未来的规划可能更倾向于去带一个完整的项目，事无巨细，不去完整的独立的领导一个项目，我觉得作为一个IT人是有遗憾的。

**录用之后**：首先去了解工作内容，熟悉工作流程。对公司使用的技术和现有的项目要尽快上手，把这些和自己的能力有机结合，发挥出最大效益。

**其他问题**：公司的产品，公司的项目组，公司对新人的培养方案，公司的晋升制度。
