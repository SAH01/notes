> 本教程目的是使用vue开发个人博客项目，做为码神之路博客（springboot项目）的前端补充，使开发人员可以成为前后端都会的全栈开发
>
> 本教程 不教 css，面向Java开发人员，不适用于专业前端

# 1. 认识VUE

> vue是一套用于构建用户界面的**渐进式框架**。需要有html，js，css的前置知识

## 1.1 入门案例

1. 新建index.html

   ~~~html
   <!DOCTYPE html>
   <html>
   	<head>
   		<meta charset="utf-8">
   		<title>vue入门案例</title>
   		
   	</head>
   	<body>
   		<div id="app">
   			{{message}}
   		</div>
   		
   		<!-- 开发环境版本，包含了有帮助的命令行警告 -->
   		<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
   		
   		<script>
   			var app = new Vue({
   				"el":'#app',
   				data:{
   					message:'Hello World Vue!!'
   				}
   			})
   		</script>
   	</body>
   </html>
   
   ~~~

2. 直接访问即可

## 1.2 响应式

> 通过Vue，我们发现页面的渲染非常方便，==vue帮我们将数据和DOM建立了关联关系==，操作变成了`响应式`的，主要数据变化，页面会进行实时渲染

**用了VUE之后，我们在操作dom的时候，就不要直接和HTML直接进行交互了，因为VUE帮我们将DOM和VUE做了绑定，在上面的入门案例中，绑定到了id=app的dom上**

验证：

在vue当中，`v-bind attribute` 被称为`指令`。指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。

~~~vue
v:bind 我们使用vue提供的bind来进行属性的绑定，这样方便在vue中进行控制
~~~

~~~html
<!--将message1绑定到span的title属性上--> 
<span v-bind:title="message1">
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
</span>
~~~

~~~js
var app = new Vue({
  el: '#app',
  data: {
    message1: '页面加载于 ' + new Date().toLocaleString()
  }
})
~~~

> 如果在控制台输入 app.message='修改值' 回车，就会再一次看到这个绑定了 `title` attribute 的 HTML 已经进行了更新。

## 1.2 条件和循环

> if （条件判断）和for（循环）也是我们经常用的，我们看一下在vue中如何使用

### 1.2.1 条件

VUE不仅可以把数据绑定到 `DOM 文本`或 `attribute`，还可以绑定到 DOM **结构**。

~~~html
<div>
				 <hr />
				 <p v-if="seen">现在你看到我了</p>
			 </div>
~~~

~~~js
<script>
			var app = new Vue({
				"el":'#app',
				data:{
					message:'Hello World Vue!!',
					message1:'页面加载于 ' + new Date().toLocaleString(),
					seen:true
				},
				created(){
				}
			})
		</script>
~~~

### 1.2.2 循环

> `v-for` 指令可以绑定数组的数据来渲染一个项目列表

~~~html
	<div>
				<hr />
				<ol>
				    <li v-for="todo in todos">
				      {{ todo.text }}
				    </li>
				</ol>
			</div>
~~~

~~~js
<script>
			var app = new Vue({
				"el":'#app',
				data:{
					message:'Hello World Vue!!',
					message1:'页面加载于 ' + new Date().toLocaleString(),
					seen:false,
					todos:[
						{
							text:'列表1'
						},
						{
							text:'列表2'
						},
						{
							text:'列表3'
						}
					]
				},
				created(){
				}
			})
		</script>
~~~

`app.todos.push({ text: '新列表' })`在控制台输入，会发现多了一个列表。



## 1.3 事件监听

> 为了让用户和你的应用进行交互，我们可以用 `v-on` 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法

~~~html
<div>
				<hr />
				<p>{{ message2 }}</p>
				<!--绑定一个点击事件-->
				<button v-on:click="reverseMessage">反转消息</button>
			</div>
~~~

~~~js
<script>
			var app = new Vue({
				"el":'#app',
				data:{
                   
					message2:'我 是 默 认 值'
				},
				created(){
				},
				methods:{
					reverseMessage(){
						this.message2 = this.message2.split(' ').reverse().join(',')
					}
				}
				
			})
		</script>
~~~

在 `reverseMessage` 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要`关注逻辑层面`即可。

# 2. 组件化应用构建

几乎任意类型的应用界面都可以抽象为一个组件树：

![image-20221003200156566](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20221003200156566.png)

在 Vue 里，一个组件本质上是一个拥有`预定义选项`的一个 `Vue 实例`。在 Vue 中`注册组件`很简单：

~~~js
// 定义名为 todo-item 的新组件
Vue.component('todo-item', {
  template: '<li>这是个待办项</li>'
})

var app = new Vue(...)
~~~

现在你可以用它构建另一个组件模板：

~~~js
<ol>
  <!-- 创建一个 todo-item 组件的实例 -->
  <todo-item></todo-item>
</ol>
~~~

我们应该能从`父作用域将数据传到子组件`才对。让我们来修改一下组件的定义，使之能够接受一个 [prop](https://cn.vuejs.org/v2/guide/components.html#通过-Prop-向子组件传递数据)：

~~~js
Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义 attribute。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
~~~

可以使用 `v-bind` 指令将待办项传到循环输出的每个组件中：

~~~html
<div id="app-7">
  <ol>
    <!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，保证唯一
    -->
    <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    ></todo-item>
  </ol>
</div>
~~~

~~~js
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: '蔬菜' },
      { id: 1, text: '奶酪' },
      { id: 2, text: '随便其它什么人吃的东西' }
    ]
  }
})
~~~

# 3. 生命周期

![Vue 实例生命周期](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/lifecycle.png)

1. beforeCreate  
2. created
3. beforeMount
4. mounted
5. beforeUpdated
6. updated
7. beforeDestroy
8. destroy



比如：

~~~js
<script>
			var app = new Vue({
				"el":'#app',
				data:{
				},
				created(){
                    alert('created')
				},
                mounted(){
                    alert('mounted')
				},
				methods:{
				}
				
			})
		</script>
~~~

# 4. 模板语法

## 4.1 文本

~~~html
<span>Message: {{ msg }}</span>
~~~

## 4.2 原始HTML

双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)：

~~~html
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
~~~

> 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。

## 4.3 Attribute

~~~html
<button v-bind:disabled="isButtonDisabled">Button</button>
~~~

如果 `isButtonDisabled` 的值是 `null`、`undefined` 或 `false`，则 `disabled` attribute 甚至不会被包含在渲染出来的 `<button>` 元素中。

## 4.4 使用JavaScript表达式

对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。

~~~js
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div v-bind:id="'list-' + id"></div>
~~~

有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。

~~~js
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
~~~

> 模板表达式都被放在沙盒中，只能访问[全局变量的一个白名单](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9)，如 `Math` 和 `Date` 。你不应该在模板表达式中试图访问用户定义的全局变量。

## 4.5 指令

### 4.5.1 参数

一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML attribute：

~~~js
<a v-bind:href="url">...</a>
~~~

### 4.5.2 动态参数

**2.6.0新增**

从 2.6.0 开始，可以用`方括号`括起来的 JavaScript 表达式作为一个指令的参数：

~~~js
<a v-bind:[attributeName]="url"> ... </a>
~~~

当attributeName=href时，等同于上面的v-bind:href="url"

### 4.5.3 修饰符

修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：

~~~html
<form v-on:submit.prevent="onSubmit">...</form>
~~~

## 4.6 缩写

v-bind 缩写：

~~~html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>
~~~

v-on 缩写:

~~~html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>
~~~

# 5. 计算属性

> 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：

~~~html
<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
~~~

在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 `message` 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。

所以，对于任何复杂逻辑，你都应当使用**计算属性**。

~~~html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
~~~

~~~js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
~~~

> 计算属性的好处是，只有在相关依赖改变的时候，才会重新计算，也就是说只要message不变，那么reversedMessage就不会重新计算，这个方法有本质的区别

**计算属性默认只有getter，如果想使用setter**

~~~js
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
~~~

# 6. 侦听器

> 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 `watch` 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。

例子：

~~~html
<div id="watch-example">
  <p>
    Ask a yes/no question:
    <input v-model="question">
  </p>
  <p>{{ answer }}</p>
</div>
~~~

~~~js
<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
  created: function () {
    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
    // 请参考：https://lodash.com/docs#debounce
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer: function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Questions usually contain a question mark. ;-)'
        return
      }
      this.answer = 'Thinking...'
      var vm = this
      axios.get('https://yesno.wtf/api')
        .then(function (response) {
          vm.answer = _.capitalize(response.data.answer)
        })
        .catch(function (error) {
          vm.answer = 'Error! Could not reach the API. ' + error
        })
    }
  }
})
</script>
~~~

> 在这个示例中，使用 `watch` 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

# 7. 模块化

> 上面是一些vue的基本使用常识，在开发vue项目的时候，需要使用模块化的方式，前提是需要安装nodejs，http://nodejs.cn/download/current/ ，下载并双击安装即可。

使用vue开发，推荐使用vue-cli生成项目，这里由于我们使用的是HBuilder，已经提供了对应的支持，直接新建即可

![image-20211207161718849](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20211207161718849.png)

## 7.1 目录结构

![image-20211207163019447](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/image-20211207163019447.png)

`package.json` : 描述这个NPM包的所有相关信息，包括作者、简介、包依赖、构建等信息，格式是严格的JSON格式。和java的maven的pom文件作用一样。

`node_modules`: 依赖需要下载后才能使用，存在依赖包的地方。使用`npm install` 安装依赖

`babel.config.js`: Babel 是一个 JavaScript 编译器。Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。

babel.config.js是项目范围配置，主要用于以下功能：

- 以编程方式创建配置
- 编译node_modules

**presets字段设定转码规则**

`postcss.config.js`:  是一个利用JS插件来对CSS进行转换的工具，这些插件非常强大，强大到无所不能。`autoprefixer`自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为CSS规则添加前缀。

`public`：存储静态资源，不经过webpack的打包处理

`src`: 源码文件夹

`assets` : 存储静态资源，**通过相对路径被引入**，这类引用会被webpack处理；

`components`：存放组件

`App.vue`：根组件

`main.js`：入口文件

> 启动后，应用会先访问public下的index.html，由于其定义了一个id=app的div，main.js做为入口文件，会new一个Vue实例，将其挂载到app上，并且注册了一个组件，就是App.vue。



运行`npm run serve` 启动项目，进行访问。





# 1. 路由

Vue Router 是 [Vue.js (opens new window)](http://cn.vuejs.org/)官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：

- 嵌套的路由/视图表
- 模块化的、基于组件的路由配置
- 路由参数、查询、通配符
- 基于 Vue.js 过渡系统的视图过渡效果
- 细粒度的导航控制
- 带有自动激活的 CSS class 的链接
- HTML5 历史模式或 hash 模式，在 IE9 中自动降级
- 自定义的滚动条行为



## 1.1 安装

1. 在package.json中添加vue-router的依赖

    ~~~js
     "vue-router": "^3.0.1",
    ~~~

    

2. 在src下新建router文件夹，并在其下创建index.js

    ~~~js
    import Vue from 'vue'
    import VueRouter from 'vue-router'
    
    Vue.use(VueRouter)
    
    
    //3. 创建 router 实例，然后传 `routes` 配置
    const router = new VueRouter({
    })
    
    export default router
    ~~~

3. 在main.js添加router的引入

    ~~~js
    import Vue from 'vue'
    import App from './App.vue'
    import router from './router'
    
    Vue.config.productionTip = false
    
    new Vue({
      router,
      render: h => h(App),
    }).$mount('#app')
    
    ~~~

4. npm install 安装依赖

## 1.2 入门

> 简单点理解，可以让我们在跳转页面的时候，不用新打开一个页面

将App.vue中的template修改如下：

~~~js
<template>
  <div id="app">
	  <p>
        <!-- 使用 router-link 组件来导航. -->
        <!-- 通过传入 `to` 属性指定链接. -->
        <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
        <router-link to="/foo">Go to Foo</router-link>
        <router-link to="/bar">Go to Bar</router-link>
      </p>
	  <!-- 路由出口 -->
	    <!-- 路由匹配到的组件将渲染在这里 -->
	    <router-view></router-view>
  </div>
</template>
~~~

在router下的index.js，修改如下：

~~~js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

// 1. 定义 (路由) 组件。
// 可以从其他文件 import 进来
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }

// 2. 定义路由
// 每个路由应该映射一个组件。
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]
//3. 创建 router 实例，然后传 `routes` 配置
const router = new VueRouter({
	routes
})

export default router
~~~

在项目根目录下创建vue.config.js

~~~js
module.exports = {
  runtimeCompiler: true,
}
~~~

重新启动进行测试。



## 1.3 动态路由

```js
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar },
  { path: '/user/:id', component: User }
]
```

> :id是路径参数，即 /user/aa, /user/bb 都会映射到相同的路由。

定义组件：

~~~js
const User = {template: '<div>User {{ $route.params.id }}</div>'}
~~~

通过`$route.params.id`获取路径参数

# 2. 博客首页

App.vue:

~~~js
<template>
  <div id="app">
	  <!-- 路由出口 -->
	    <!-- 路由匹配到的组件将渲染在这里 -->
	  <router-view></router-view>
	  <!--组件 回到顶部-->
	  <go-top></go-top>
  </div>
</template>

<script>
import GoTop from '@/components/gotop/GoTop'

export default {
  name: 'app',
  components: {
	  GoTop
  }
}
</script>



<style>
* { margin: 0; padding: 0; }

body {
	background-color: #f5f5f5;
	font-weight: 400;
	font-family: "Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;
	line-height: 1.5;
}
a {
    cursor: pointer;
    text-decoration: none;
	/* 动画效果，css的属性值在一定的时间内从一个状态平滑的过渡到另一个状态 ease-out　先快，后慢 */
    transition: none 86ms ease-out;
}
a:hover {
	color: #00aaff;
}

html{height:100%;}
body{min-height:100%;}
/*生成相对定位的元素，相对于其正常位置进行定位*/
body{position:relative;}

</style>

~~~

## 2.1 回到顶部组件

Vue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡

- 条件渲染 (使用 `v-if`)
- 条件展示 (使用 `v-show`)
- 动态组件
- 组件根节点

在components下新建gotop目录，新建组件GoTop.vue

~~~js
<template>
  <!--<transition name="el-zoom-in-center">-->
  <transition>
    <div @click="toTop" v-show="topShow" class="me-to-top"><i class="el-icon-caret-top"></i></div>
  </transition>
</template>

<script>
  export default {
    name: 'GoTop',
    data() {
      return {
        topShow: false
      }
    },
    methods: {
      toTop() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        this.topShow = false;
      },
      needToTop() {
        let curHeight = document.documentElement.scrollTop || document.body.scrollTop;

        if (curHeight > 400) {
          this.topShow = true;
        } else {
          this.topShow = false;
        }

      }
    },
    mounted() {
      /**
       * 等到整个视图都渲染完毕
       */
      this.$nextTick(function () {
        window.addEventListener('scroll', this.needToTop);
      });
    }
  }
</script>

<style>
  .me-to-top {
    background-color: #fff;
    position: fixed;
    right: 100px;
    bottom: 150px;
    width: 40px;
    height: 40px;
    border-radius: 20px;
    cursor: pointer;
    transition: .3s;
    box-shadow: 0 0 6px rgba(0, 0, 0, .12);
    z-index: 5;
  }

  .me-to-top i {
    color: #00d1b2;
    display: block;
    line-height: 40px;
    text-align: center;
    font-size: 18px;
  }

</style>

~~~

## 2.2 添加首页的路由

> 新建views文件夹，用于存放页面
>
> 在views下新建 index.vue，做为首页
>
> 设置路由，访问根路径时，展示index.vue的内容

index.vue:

~~~html
<template>
	<div>
		
		我是首页
		
			<p style="height: 200px;">asd</p>
			<p style="height: 200px;">asd</p>
			<p style="height: 200px;">asd</p>
			<p style="height: 200px;">asd</p>
			<p style="height: 200px;">asd</p>
	</div>
</template>

<script>
</script>

<style>
</style>

~~~

router/index.js:

~~~js
const routes = [
  { path: '/', component: r => require.ensure([], () => r(require('@/views/Index')), 'index') },
]
~~~

运行发现：回到顶部的组件无样式，这是因为用到了`ELementUI`，我们还没有使用

## 2.3 引入ElementUI

~~~js
"element-ui": "^2.0.10",
~~~

main.js

~~~js
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css';
Vue.use(ElementUI)
~~~

安装 重新测试

## 2.4 首页布局

views/index.vue：

~~~html
<template>
  <div v-title data-title="码神之路-blog">
    <el-container>

      <el-main class="me-articles">
			主区域
		
      </el-main>

      <el-aside>

			侧边栏,右侧
      </el-aside>

    </el-container>
  </div>
</template>

<script>

  export default {
    name: 'Index',
    created() {
    },
    data() {
      return {
      }
    },
    methods: {
    },
    components: {
    }
  }
</script>

<style scoped>

  .el-container {
    width: 960px;
  }

  .el-aside {
    margin-left: 20px;
    width: 260px;
  }

  .el-main {
    padding: 0px;
    line-height: 16px;
  }

  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 20px;
  }
</style>

~~~

## 2.5 文章列表

在components下新建article，在其下新建ArticleItem.vue:

~~~html
<template>
  <el-card class="me-area" :body-style="{ padding: '16px' }">
    <div class="me-article-header">

      <a @click="view(id)" class="me-article-title">{{title}}</a>
      <el-button v-if="weight > 0" class="me-article-icon" type="text">置顶</el-button>
      <span class="me-pull-right me-article-count">
	    	<i class="me-icon-comment"></i>&nbsp;{{commentCounts}}
	    </span>
      <span class="me-pull-right me-article-count">
	    	<i class="el-icon-view"></i>&nbsp;{{viewCounts}}
	    </span>
    </div>

    <div class="me-artile-description">
      {{summary}}
    </div>
    <div class="me-article-footer">
	  	<span class="me-article-author">
	    	<i class="me-icon-author"></i>&nbsp;<el-tag>{{author}}</el-tag>
	    </span>

      <el-tag v-for="t in tags" :key="t.tagName" size="mini" type="success">{{t.tagName}}</el-tag>

      <span class="me-pull-right me-article-count">
	    	<i class="el-icon-time"></i>&nbsp;{{createDate | format}}
	    </span>

    </div>
  </el-card>
</template>

<script>
  import { formatTime } from "../../utils/time";

  export default {
    name: 'ArticleItem',
    props: {
      id: String,
      weight: Number,
      title: String,
      commentCounts: Number,
      viewCounts: Number,
      summary: String,
      author: String,
      tags: Array,
      createDate: String
    },
    data() {
      return {}
    },
    methods: {
      view(id) {
        this.$router.push({path: `/view/${id}`})
      }
    }
  }
</script>

<style scoped>

  .me-article-header {
    /*padding: 10px 18px;*/
    padding-bottom: 10px;
  }

  .me-article-title {
    font-weight: 600;
  }

  .me-article-icon {
    padding: 3px 8px;
  }

  .me-article-count {
    color: #ff00ff;
    padding-left: 14px;
    font-size: 13px;
  }

  .me-pull-right {
    float: right;
  }

  .me-artile-description {
    font-size: 13px;
    line-height: 24px;
    margin-bottom: 10px;
  }

  .me-article-author {
    color: #aa00ff;
    padding-right: 18px;
    font-size: 13px;
  }

  .el-tag {
     margin-left: 6px;
     color: #ffffff;
     background-color: #ff00ff;
  }

</style>

~~~



用到的时间工具类：

utils/time.js

~~~js
export function formatTime(time) {
  const d = new Date(time)
  const now = Date.now()

  const diff = (now - d) / 1000

  if (diff < 30) {
    return '刚刚'
  } else if (diff < 3600) { // less 1 hour
    return Math.ceil(diff / 60) + '分钟前'
  } else if (diff < 3600 * 24) {
    return Math.ceil(diff / 3600) + '小时前'
  } else if (diff < 3600 * 24 * 2) {
    return '1天前'
  }

  return time
}

~~~



## 2.6 Main区域引入文章列表

> 上方定义组件后，我们在index.vue的el-main区域进行引入，并且给一些测试数据

在main.js 中 添加如下内容：

~~~js
import {formatTime} from "./utils/time";
//自定义指令
Vue.directive('title',  function (el, binding) {
  document.title = el.dataset.title
})
// 格式化时间
Vue.filter('format', formatTime)
~~~

index.vue:

~~~html
  <el-main class="me-articles">
		
			<ArticleItem 
				v-for="article in articles" :key="article.id" v-bind="article"
			 >
			</ArticleItem>
      </el-main>

~~~

定义测试数据：

~~~js
data() {
      return {
		articles:[
			{
				id:"1",
				weight:1,
				title:"标题1",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"3333"
			},
			{
				id:"2",
				weight:1,
				title:"标题2", 
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"111"
			},
			{
				id:"3",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"222"
			}
		]
      }
    },
~~~

## 2.7 下拉进行分页组件

> 文章列表是一个分页列表，这里我们需要实现，下拉分页，即如果拉到底部，就会请求下一页的数据，如果有数据就加载出来，如果没数据，就证明到达最后一页



新建scrollpage/index.vue

加载框：https://element.eleme.cn/#/zh-CN/component/loading#options

~~~js
<template>

  <div ref="scroll" id="scroll-page" style="overflow: hidden">
    <slot></slot>
	<!--loading动画，加载的数据的过程中显示 elementui load-->
    <div
      style="height: 40px;margin-top: 10px;z-index: 1"
      v-loading="loading"
      element-loading-text="拼命加载中"
      element-loading-spinner="el-icon-loading"
      element-loading-background="rgba(245,245,245)"></div>
  </div>

</template>

<script>
  export default {
    props: {
      loading: Boolean,
      noData: Boolean,
      offset: Number
    },
    name: "index",
    mounted() {
		//绑定事件监听，滚动的时候触发
      window.addEventListener('scroll', this.handleScroll, false);
    },
    beforeDestroy() {
		//移出事件监听
      window.removeEventListener('scroll', this.handleScroll)
    },
    data() {
      return {
        scrollAction: {
          x: 'undefined',
          y: 'undefined'
        }
      }
    },
    methods: {
      handleScroll(e) {
        var that = this
		//
        if (!that.noData) {
			//如果有数据，触发
          let curHeight = document.documentElement.scrollTop || document.body.scrollTop
          //获取div区域
		  var scrollPage = document.getElementById('scroll-page');
			
          if ((curHeight + window.innerHeight >= that.$refs.scroll.offsetHeight + that.offset) && that.isDownDirection()) {
            //判断是否到达底部
			if (!that.loading) {
				//调用load加载数据
              	that.$emit('load')
            }
          }
        }
      },
      isDownDirection() {
        if (typeof this.scrollAction.x == 'undefined') {
          this.scrollAction.x = window.pageXOffset;
          this.scrollAction.y = window.pageYOffset;
        }
        var diffX = this.scrollAction.x - window.pageXOffset;
        var diffY = this.scrollAction.y - window.pageYOffset;

        this.scrollAction.x = window.pageXOffset;
        this.scrollAction.y = window.pageYOffset;

        if (diffX < 0) {
          // Scroll right
        } else if (diffX > 0) {
          // Scroll left
        } else if (diffY < 0) {
          // Scroll down
          return true
        } else if (diffY > 0) {
          // Scroll up
        } else {
          // First scroll event
        }
        return false
      }

    }
  }
</script>

<style scoped>

</style>

~~~



## 2.8 文章列表改进

在views下新建common文件夹，其中新建ArticleScrollPage.vue, 将文章列表放入滚动分页区域内

~~~html
<template>
  <scroll-page :loading="loading" :offset="offset" :no-data="noData" v-on:load="load">
    <article-item v-for="article in articles" :key="article.id" v-bind="article">
	</article-item>
  </scroll-page>
</template>

<script>
  import ArticleItem from '@/components/article/ArticleItem'
  import ScrollPage from '@/components/scrollpage'

  export default {
    name: "ArticleScrollPage",
    props: {
      offset: {
        type: Number,
        default: 0
      }
    },
    watch: {
    },
    created() {
      this.getArticles()
    },
    data() {
      return {
        loading: false,
        noData: false,
		//分页信息
        innerPage: {
          pageSize: 5,
          page: 1,
          name: 'a.createDate',
          sort: 'desc'
        },
		//文章列表
        articles: []
      }
    },
    methods: {
      load() {
		  //下拉触发分页的时候 进行接口加载
		  alert("触发分页")
        this.getArticles()
      },
      getArticles() {
        let that = this
        that.loading = true
		that.articles = that.articles.concat([
			{
				id:"1",
				weight:1,
				title:"标题1",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"3333"
			},
			{
				id:"232",
				weight:1,
				title:"标题1",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"3333"
			},
			{
				id:"2",
				weight:1,
				title:"标题2", 
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"11111"
			},
			{
				id:"3",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"2222"
			},
			{
				id:"4",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"2222"
			},
			{
				id:"5",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"2222"
			},
			{
				id:"6",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"2222"
			},
			{
				id:"7",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"2222"
			},
			{
				id:"8",
				weight:1,
				title:"标题3",
				commentCounts:123,
				viewCounts:123,
				summary:"概要11",
				author:"作者",
				tags:[{"tagName":"vue"}],
				createDate:"2222"
			}
		]);
		
		that.loading = false

      }
    },
    components: {
      'article-item': ArticleItem,
      'scroll-page': ScrollPage
    }

  }
</script>

<style scoped>
  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 10px;

  }
</style>

~~~

首页变更：

~~~html
<template>
  <div v-title data-title="码神之路-blog">
    <el-container>

      <el-main class="me-articles">
			<ArticleScrollPage></ArticleScrollPage>
      </el-main>

      <el-aside>
			侧边栏,右侧
      </el-aside>

    </el-container>
  </div>
</template>

<script>
 import ArticleScrollPage from '@/views/common/ArticleScrollPage.vue'
  export default {
    name: 'Index',
    created() {
    },
    data() {
      return {
      }
    },
    methods: {
    },
    components: {
		ArticleScrollPage
    }
  }
</script>

<style scoped>

  .el-container {
    width: 960px;
  }

  .el-aside {
    margin-left: 20px;
  }

  .el-main {
    padding: 0px;
    line-height: 16px;
  }

  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 20px;
  }
</style>

~~~

## 2.9 数据请求

> 接下来，我们需要将文章数据变成动态的，也就是通过发ajax请求，从后端请求数据，并进行展示。

**后端-是码神之路博客系统，已经实现好的**

> 发起http请求我们使用axios: 易用、简洁且高效的http库
>
> http://www.axios-js.com/zh-cn/docs/vue-axios.html

加入依赖：

~~~json
npm install --save axios vue-axios
~~~

~~~js
//将下面代码 加入 main.js
import Vue from 'vue'
import axios from 'axios'
import VueAxios from 'vue-axios'

Vue.use(VueAxios, axios)
~~~

然后就可以按照 下面的方式 使用：

~~~js
Vue.axios.get(api).then((response) => {
    //response.data == 后台返回的数据
  console.log(response.data)
})

this.axios.get(api).then((response) => {
  console.log(response.data)
})

this.$http.get(api).then((response) => {
  console.log(response.data)
})
~~~

> 在ArticleScrollPage的getArticles中 发起请求

~~~js
getArticles() {
        let that = this
        that.loading = true
		this.axios.post("http://localhost:8888/articles/findArticlePage",this.innerPage).then((res)=>{
			if(res.data.success){
				if(res.data.data.length <= 0){
					that.noData = true;
				}else{
					this.articles = this.articles.concat(res.data.data);
                    this.innerPage.page += 1;
				}
			}else{
				that.$message({type: 'error', message: res.data.message, showClose: true})
			}
			
		}).catch((err)=>{
			//有报错
			that.$message({type: 'error', message: '文章加载失败!', showClose: true})
			
		}).finally(()=>{
			this.loading = false;
		});
		

      }
~~~

## 2.10 统一请求处理

> 上面我们的请求路径写的比较死，如果更换ip和port的话，需要在代码中到处更改，我们应该将其提取出去

在src下创建request文件夹，在其下创建index.js：

~~~js
import axios from 'axios'

const service = axios.create({
  baseURL: "http://localhost:8888",
  timeout: 10000
})

export default service
~~~

在src下创建api文件夹，在其下创建article.js：

~~~js
import request from "@/request"

export function getArticles(page) {
	return request({
		  method: 'post',
		  url: '/articles/findArticlePage',
		  data: page
		})
}
~~~

更改ArticleScrollPage.vue中的请求:

~~~js
 import {getArticles} from '@/api/article'

getArticles(this.innerPage).then((res)=>{
			if(res.data.success){
				if(res.data.data.length <= 0){
					that.noData = true;
				}else{
					this.innerPage.page += 1;
					this.articles = this.articles.concat(res.data.data);
				}
			}else{
				that.$message({type: 'error', message: res.data.message, showClose: true})
			}
		}).catch((err)=>{
			//有报错
			that.$message({type: 'error', message: '文章加载失败!', showClose: true})
			
		}).finally(()=>{
			this.loading = false;
		});
~~~

# 3. 补全页面显示

## 3.1 我的信息卡片

src/card/CardMe.vue:

~~~js
<template>
  <el-card>
    <h1 class="me-author-name">码神之路</h1>
    <div class="me-author-description">
      <span><i class="el-icon-location-outline"></i> &nbsp;北京&海淀</span>
      <span><i class="me-icon-job"></i> &nbsp;java开发</span>
    </div>
    <div class="me-author-tool">
      <i @click="showTool(qq)" :title="qq.title" class="iconfont icon-qq"></i>
      <i @click="showTool(bilibili)" :title="bilibili.title" class="iconfont icon-bilibili-fill"></i>
    </div>
  </el-card>

</template>

<script>
  export default {
    name: 'CardMe',
    data() {
      return {
        qq: {title: 'QQ', message: '130823919'},
        bilibili: {
          title: '哔哩哔哩',
          message: '<a target="_blank" href="https://space.bilibili.com/473844125">https://space.bilibili.com/473844125</a>'
        }
      }
    },
    methods: {
      showTool(tool) {
        this.$message({
          duration: 0,
          showClose: true,
          dangerouslyUseHTMLString: true,
          message: '<strong>' + tool.message + '</strong>'
        });
      }
    }
  }
</script>

<style scoped>
  .me-author-name {
    text-align: center;
    font-size: 30px;
    border-bottom: 1px solid #00aaff;
  }

  .me-author-description {
    padding: 8px 0;
  }

  .me-icon-job {
    padding-left: 16px;
  }

  .me-author-tool {
    text-align: center;
    padding-top: 10px;
  }

  .me-author-tool i {
    cursor: pointer;
    padding: 4px 10px;
    font-size: 30px;
  }
</style>

~~~

在index.vue中引入：

~~~js
<template>
  <div v-title data-title="码神之路-blog">
    <el-container>

      <el-main class="me-articles">
			<ArticleScrollPage></ArticleScrollPage>
      </el-main>

      <el-aside>
			<CardMe></CardMe>
      </el-aside>

    </el-container>
  </div>
</template>

<script>
 import ArticleScrollPage from '@/views/common/ArticleScrollPage.vue'
 import CardMe from '@/components/card/CardMe.vue'
  export default {
    name: 'Index',
    created() {
    },
    data() {
      return {
      }
    },
    methods: {
    },
    components: {
		ArticleScrollPage,
		CardMe
    }
  }
</script>

<style scoped>

  .el-container {
    width: 960px;
  }

  .el-aside {
    margin-left: 20px;
  }

  .el-main {
    padding: 0px;
    line-height: 16px;
  }

  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 20px;
  }
</style>

~~~

## 3.2 添加头和底

> 我们需要构建一个Home组件，将Header，Body，Footer整合在一起

Home.vue：

~~~js
<template>
  <div id="home">
    <el-container>

    	<base-header :activeIndex="activeIndex"></base-header>

		  <router-view class="me-container"/>

			<base-footer v-show="footerShow"></base-footer>

	  </el-container>

  </div>

</template>

<script>
import BaseFooter from '@/components/BaseFooter'
import BaseHeader from '@/views/BaseHeader'

export default {
  name: 'Home',
  data (){
  	return {
  			activeIndex: '/',
  			footerShow:true
  	}
  },
  components:{
  	'base-header':BaseHeader,
  	'base-footer':BaseFooter
  },
  beforeRouteEnter (to, from, next){
  	 next(vm => {
    	vm.activeIndex = to.path
  	})
  },
  beforeRouteUpdate (to, from, next) {
	  if(to.path == '/'){
	  	this.footerShow = true
	  }else{
	  	this.footerShow = false
	  }
	  this.activeIndex = to.path
	  next()
	}
}
</script>

<style>

.me-container{
  margin: 100px auto 140px;
}
</style>

~~~

BaseHeader.vue:

~~~js
<template>
  <el-header class="me-area">
    <el-row class="me-header">

      <el-col :span="4" class="me-header-left">
        <router-link to="/" class="me-title">
          <img src="../assets/img/logo.png" />
        </router-link>
      </el-col>

      <el-col v-if="!simple" :span="16">
        <el-menu :router=true menu-trigger="click" active-text-color="#00aaff" :default-active="activeIndex"
                 mode="horizontal">
          <el-menu-item index="/">首页</el-menu-item>
          <el-menu-item index="/category/all">文章分类</el-menu-item>
          <el-menu-item index="/tag/all">标签</el-menu-item>
          <el-menu-item index="/archives">文章归档</el-menu-item>

          <el-col :span="4" :offset="4">
            <el-menu-item index="/write"><i class="el-icon-edit"></i>写文章</el-menu-item>
          </el-col>

        </el-menu>
      </el-col>

      <template v-else>
        <slot></slot>
      </template>

      <el-col :span="4">
        <el-menu :router=true menu-trigger="click" mode="horizontal" active-text-color="#00aaff">

          <template v-if="!user.login">
            <el-menu-item index="/login">
              <el-button type="text">登录</el-button>
            </el-menu-item>
            <el-menu-item index="/register">
              <el-button type="text">注册</el-button>
            </el-menu-item>
          </template>

          <template v-else>
            <el-submenu index>
              <template slot="title">
                <img class="me-header-picture" :src="user.avatar"/>
              </template>
              <el-menu-item index @click="logout"><i class="el-icon-back"></i>退出</el-menu-item>
            </el-submenu>
          </template>
        </el-menu>
      </el-col>

    </el-row>
  </el-header>
</template>

<script>
  export default {
    name: 'BaseHeader',
    props: {
      activeIndex: String,
      simple: {
        type: Boolean,
        default: false
      }
    },
    data() {
      return {
		  user:{
			login:false,
			avatar:""
		  }
	  }
    },
    computed: {
    },
    methods: {
    }
  }
</script>

<style>
  .el-button{
    color: #00aaff;
  }

  .el-header {
    position: fixed;
    z-index: 1024;
    min-width: 100%;
    box-shadow: 0 2px 3px hsla(0, 0%, 7%, .1), 0 0 0 1px hsla(0, 0%, 7%, .1);
  }

  .me-title {
    margin-top: 10px;
    font-size: 24px;
  }

  .me-header-left {
    margin-top: 10px;
  }

  .me-title img {
    max-height: 2.4rem;
    max-width: 100%;
  }

  .me-header-picture {
    width: 36px;
    height: 36px;
    border: 1px solid #ddd;
    border-radius: 50%;
    vertical-align: middle;
    background-color: #00aaff;
  }
</style>

~~~

BaseFooter.vue:

~~~js
<template>
  <el-footer class="me-area">
    <div class="me-footer">
      <p>Designed by
        <strong>
          <router-link to="/" class="me-login-design-color">码神之路</router-link>
        </strong>
      </p>
    </div>
  </el-footer>

</template>

<script>

  export default {
    name: 'BaseFooter',
    data() {
      return {}
    },
    methods: {},
    mounted() {
    }
  }
</script>

<style>

  .el-footer {
    min-width: 100%;
    box-shadow: 0 -2px 3px hsla(0, 0%, 7%, .1), 0 0 0 1px hsla(0, 0%, 7%, .1);
    position: absolute;
    bottom: 0;
    left: 0;
    z-index: 1024;
  }

  .me-footer {
    text-align: center;
    line-height: 60px;
    font-family: 'Open Sans', sans-serif;
    font-size: 18px;

  }

  .me-login-design-color {
    color: #00aaff !important;
  }

</style>

~~~

修改路由：

~~~js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '@/Home'

Vue.use(VueRouter)

// 1. 定义 (路由) 组件。
// 可以从其他文件 import 进来


// 2. 定义路由
// 每个路由应该映射一个组件。
const routes = [
	{
	  path: '',
	  name: 'Home',
	  component: Home,
	  children: [
			{
			  path: '/',
			  component: r => require.ensure([], () => r(require('@/views/Index')), 'index')
			},
		],
	}
]
//3. 创建 router 实例，然后传 `routes` 配置
const router = new VueRouter({
	routes
})

export default router
~~~

**博客首页基本成型。**

# 1. 最热标签

## 1.1 组件

components/card下创建CardTag.vue：

~~~js
<template>
  <el-card :body-style="{ padding: '8px 18px' }">
    <div slot="header" class="me-tag-header">
      <span>最热标签</span>
      <a @click="moreTags" class="me-pull-right me-tag-more">查看全部</a>
    </div>

    <ul class="me-tag-list">
      <li class="me-tag-item" v-for="t in tags" :key="t.id">
        <!--type="primary"-->
        <el-button @click="tag(t.id)" size="mini" type="primary" round plain>{{t.tagName}}</el-button>
      </li>
    </ul>
  </el-card>

</template>

<script>
  export default {
    name: 'CardTag',
    props: {
      tags: Array
    },
    data() {
      return {}
    },
    methods: {
      moreTags() {
        this.$router.push('/tag/all')
      },
      tag(id) {
        this.$router.push({path: `/tag/${id}`})
      }
    }
  }
</script>

<style scoped>

  .me-tag-header {
    font-weight: 600;
  }

  .me-tag-more {
    font-size: 14px;
    color: #78b6f7;
  }

  .me-tag-list {
    list-style-type: none;
  }

  .me-tag-item {
    display: inline-block;
    padding: 4px;
    font-size: 14px;
    color: #5FB878;
  }

  .me-tag-item a:hover {
    text-decoration: underline;
  }
</style>

~~~

> 上面有两个触发方法，一个是查看全部的tag，跳转到/tag/all，一个是查看标签下的文章，跳转到/tag/{tagId}
>
> 需要外部传值 tags，标签列表，其中Tag必须有id，tagName这两个属性

## 1.2 添加到侧边栏

index.vue:

~~~js
<template>
	<div>
			
			<el-container>
			  
			  <el-main class="me-articles">
				<ArticleScrollPage>
					
				</ArticleScrollPage>
			  </el-main>
			  <el-aside>
				  <CardMe></CardMe>
				  <card-tag :tags="hotTags"></card-tag>
			  </el-aside>
			</el-container>
		</div>
</template>

<script>
	import ArticleScrollPage from "@/components/common/ArticleScrollPage.vue"
	import CardMe from '@/components/card/CardMe.vue'
	import CardTag from '@/components/card/CardTag.vue'
	import {getHotTags} from '@/api/tag'
	export default{
		data() {
		  return {
			  hotTags: []
		  }    
		},
		created(){
			this.getHotTags();
		},
		methods:{
			getHotTags(){
				//发起http请求 请求后端的数据
				getHotTags().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.hotTags = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			}
		},
		components:{
			ArticleScrollPage,
			CardMe,
			"card-tag":CardTag
		}
	}
</script>

<style scoped>

  .el-container {
    width: 960px;
  }

  .el-aside {
    margin-left: 20px;
    width: 260px;
  }

  .el-main {
    padding: 0px;
    line-height: 16px;
  }

  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 20px;
  }
</style>

~~~

## 1.3 api

api/tag.js

~~~js
import request from '@/request'


export function getHotTags() {
  return request({
    url: '/tags/hot',
    method: 'get',
  })
}
~~~

# 2. 最热文章+最新文章

## 2.1 组件

CardArticle.vue:

~~~js
<template>
  <el-card :body-style="{ padding: '8px 18px' }">
    <div slot="header" class="me-category-header">
      <span>{{cardHeader}}</span>
    </div>

    <ul class="me-category-list">
      <li v-for="a in articles" @click="view(a.id)" :style="itemStyle" :key="a.id" class="me-category-item"><a>{{a.title}}</a>
      </li>
    </ul>
  </el-card>

</template>

<script>
  export default {
    name: 'CardArticle',
    props: {
      cardHeader: {
        type: String,
        required: true
      },
      articles: {
        type: Array,
        required: true
      },
      itemStyle: Object
    },
    data() {
      return {}
    },
    methods: {
      view(id) {
        this.$router.push({path: `/view/${id}`})
      }
    }
  }
</script>

<style scoped>
  .me-category-header {
    font-weight: 600;
  }

  .me-category-list {
    list-style-type: none;
  }

  .me-category-item {
    padding: 4px;
    font-size: 14px;
    color: #5FB878;
  }

  .me-category-item a:hover {
    text-decoration: underline;
  }
</style>

~~~

## 2.2 添加到侧边栏

~~~html
<template>
	<div>
			
			<el-container>
			  
			  <el-main class="me-articles">
				<ArticleScrollPage>
					
				</ArticleScrollPage>
			  </el-main>
			  <el-aside>
				  <CardMe></CardMe>
				  <card-tag :tags="hotTags"></card-tag>
				  <card-article cardHeader="最热文章" :articles="hotArticles"></card-article>
				  <card-article cardHeader="最新文章":articles="newArticles"></card-article>
			  </el-aside>
			</el-container>
		</div>
</template>

<script>
	import ArticleScrollPage from "@/components/common/ArticleScrollPage.vue"
	import CardMe from '@/components/card/CardMe.vue'
	import CardTag from '@/components/card/CardTag.vue'
	import CardArticle from '@/components/card/CardArticle'
	import {getHotTags} from '@/api/tag'
	import {getHotArticles,getNewArticles} from '@/api/article'
	export default{
		data() {
		  return {
			  hotTags: [],
			  hotArticles: [],
			  newArticles: []
		  }    
		},
		created(){
			this.getHotTags();
			this.getHotArticles();
			this.getNewArticles();
		},
		methods:{
			getHotTags(){
				//发起http请求 请求后端的数据
				getHotTags().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.hotTags = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			getHotArticles(){
				//发起http请求 请求后端的数据
				getHotArticles().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.hotArticles = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			getNewArticles(){
				//发起http请求 请求后端的数据
				getNewArticles().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.newArticles = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			}
		},
		components:{
			ArticleScrollPage,
			CardMe,
			"card-tag":CardTag,
			"card-article":CardArticle
		}
	}
</script>

<style scoped>

  .el-container {
    width: 960px;
  }

  .el-aside {
    margin-left: 20px;
    width: 260px;
  }

  .el-main {
    padding: 0px;
    line-height: 16px;
  }

  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 20px;
  }
</style>

~~~

## 2.3 api

~~~js
import request from "@/request"


export function getHotArticles() {
  return request({
    url: '/articles/hot',
    method: 'post'
  })
}

export function getNewArticles() {
  return request({
    url: '/articles/new',
    method: 'post'
  })
}

~~~

# 3. 文章归档

## 3.1 组件

CardArchive.vue:

~~~js
<template>

  <el-card :body-style="{ padding: '8px 18px' }">
    <div slot="header" class="me-category-header">
      <span>{{cardHeader}}</span>
    </div>

    <ul class="me-category-list">
      <li v-for="a in archives" @click="view(a.year, a.month)" :key="a.year + a.month" class="me-category-item"><a>{{`${a.year}年${a.month}月(${a.count})`}}</a>
      </li>
    </ul>
  </el-card>

</template>

<script>
  export default {
    name: "CardArchive",
    props: {
      cardHeader: {
        type: String,
        required: true
      },
      archives: {
        type: Array,
        required: true
      }
    },
    methods: {
      view(year, month) {
        this.$router.push({path: `/archives/${year}/${month}`})
      }
    }
  }
</script>

<style scoped>

  .me-category-header {
    font-weight: 600;
  }

  .me-category-list {
    list-style-type: none;
  }

  .me-category-item {
    display: inline-block;
    width: 40%;
    padding: 4px;
    font-size: 14px;
    color: #5FB878;
  }

  .me-category-item a:hover {
    text-decoration: underline;
  }

</style>

~~~

## 3.2 添加到侧边栏

~~~html
<template>
	<div>
			
			<el-container>
			  
			  <el-main class="me-articles">
				<ArticleScrollPage>
					
				</ArticleScrollPage>
			  </el-main>
			  <el-aside>
				  <CardMe></CardMe>
				  <card-tag :tags="hotTags"></card-tag>
				  <card-article cardHeader="最热文章" :articles="hotArticles"></card-article>
				  <card-archive cardHeader="文章归档" :archives="archives"></card-archive>
				  <card-article cardHeader="最新文章":articles="newArticles"></card-article>
			  </el-aside>
			</el-container>
		</div>
</template>

<script>
	import ArticleScrollPage from "@/components/common/ArticleScrollPage.vue"
	import CardMe from '@/components/card/CardMe.vue'
	import CardTag from '@/components/card/CardTag.vue'
	import CardArticle from '@/components/card/CardArticle'
	import CardArchive from '@/components/card/CardArchive'
	import {getHotTags} from '@/api/tag'
	import {getHotArticles,getNewArticles,getArchives} from '@/api/article'
	export default{
		data() {
		  return {
			  hotTags: [],
			  hotArticles: [],
			  newArticles: [],
			  archives:[]
		  }    
		},
		created(){
			this.getHotTags();
			this.getHotArticles();
			this.getNewArticles();
			this.getArchives();
			
		},
		methods:{
			getArchives(){
				//发起http请求 请求后端的数据
				getArchives().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.archives = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			getHotTags(){
				//发起http请求 请求后端的数据
				getHotTags().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.hotTags = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			getHotArticles(){
				//发起http请求 请求后端的数据
				getHotArticles().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.hotArticles = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			getNewArticles(){
				//发起http请求 请求后端的数据
				getNewArticles().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.newArticles = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			}
		},
		components:{
			ArticleScrollPage,
			CardMe,
			"card-tag":CardTag,
			"card-article":CardArticle,
			"card-archive":CardArchive
		}
	}
</script>

<style scoped>

  .el-container {
    width: 960px;
  }

  .el-aside {
    margin-left: 20px;
    width: 260px;
  }

  .el-main {
    padding: 0px;
    line-height: 16px;
  }

  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 20px;
  }
</style>

~~~



## 3.3 Api

~~~js
export function getArchives() {
  return request({
    url: '/articles/listArchives',
    method: 'post'
  })
}
~~~

# 4. 文章分类

## 4.1 组件

~~~js
<template>
	<div class="me-allct-body" v-title :data-title="categoryTagTitle" >
	    <el-container class="me-allct-container">
	      <el-main>
	        <el-tabs v-model="activeName">
	          <el-tab-pane label="文章分类" name="category">
	            <ul class="me-allct-items">
	              <li v-for="c in categorys" @click="view(c.id)" :key="c.id" class="me-allct-item">
	                <div class="me-allct-content">
	                  <a class="me-allct-info">
	                    <img class="me-allct-img" :src="c.avatar?c.avatar:defaultAvatar"/>
	                    <h4 class="me-allct-name">{{c.categoryName}}</h4>
	                    <p class="me-allct-description">{{c.description}}</p>
	                  </a>
	
	                  <div class="me-allct-meta">
	                    <span>{{c.articles}} 文章</span>
	                  </div>
	                </div>
	              </li>
	            </ul>
	          </el-tab-pane>
	          <el-tab-pane label="标签" name="tag">
	            <ul class="me-allct-items">
	              <li v-for="t in tags" @click="view(t.id)" :key="t.id" class="me-allct-item">
	                <div class="me-allct-content">
	                  <a class="me-allct-info">
	                    <img class="me-allct-img" :src="t.avatar?t.avatar:defaultAvatar"/>
	                    <h4 class="me-allct-name">{{t.tagName}}</h4>
	                  </a>
	
	                  <div class="me-allct-meta">
	                    <span>{{t.articles}}  文章</span>
	                  </div>
	                </div>
	              </li>
	            </ul>
	          </el-tab-pane>
	        </el-tabs>
	      </el-main>
	    </el-container>
	  </div>
</template>

<script>
	import defaultAvatar from '@/assets/img/logo.png'
	import {listTagsDetail} from "@/api/tag"
	import {listCategorysDetail} from "@/api/category"
	export default {
		name: "BlogAllCategoryTag",
		data(){
			return {
				categorys: [],
				tags: [],
				activeName: "category",
				defaultAvatar : defaultAvatar
			}
		},
		computed:{
			activeName: {
				get(){
					return this.$router.params.type;
				},
				set(newValue){
					 this.activeName = newValue
				}
			},
			categoryTagTitle() {
				if(this.activeName == 'category'){
					return "文章分类-码神之路"
				}else{
					return "标签-码神之路"
				}
			}
		},
		created(){
			this.listCategorys();
			this.listTags();
		},
		methods:{
			//获取全部的分类列表
			listCategorys(){
				//发起http请求 请求后端的数据
				listCategorysDetail().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.categorys = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			//获取全部的标签列表
			listTags(){
				//发起http请求 请求后端的数据
				listTagsDetail().then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.tags = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			}
		}
	}
</script>

<style>
  .me-allct-body {
    margin: 60px auto 140px;
  }

  .me-allct-container {
    width: 1000px;
  }

  .me-allct-items {
    padding-top: 2rem;
  }

  .me-allct-item {
    width: 25%;
    display: inline-block;
    margin-bottom: 2.4rem;
    padding: 0 .7rem;
    box-sizing: border-box;
  }

  .me-allct-content {
    display: inline-block;
    width: 100%;
    background-color: #fff;
    border: 1px solid #f1f1f1;
    transition: border-color .3s;
    text-align: center;
    padding: 1.5rem 0;
  }

  .me-allct-info {
    cursor: pointer;
  }

  .me-allct-img {
    margin: -40px 0 10px;
    width: 60px;
    height: 60px;
    vertical-align: middle;

  }

  .me-allct-name {
    font-size: 21px;
    font-weight: 150;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-top: 4px;
  }

  .me-allct-description {
    min-height: 50px;
    font-size: 13px;
    line-height: 25px;
  }

  .me-allct-meta {
    font-size: 12px;
    color: #969696;
  }
</style>

~~~

## 4.2 路由

~~~js
{
          path: '/:type/all',
          component: r => require.ensure([], () => r(require('@/views/blog/BlogAllCategoryTag')), 'blogallcategorytag')
        }
~~~

> 因为文章分类下，可以选择标签，所以type是需要传递的路径参数，如果是category，那么就显示所有分类，如果是tag，那么就显示所有标签

## 4.3 api

category.js

~~~js
import request from "@/request"


export function listCategorysDetail() {
	return request({
		  method: 'get',
		  url: '/categorys/detail'
		})
}
~~~

tag.js:

~~~js
import request from "@/request"

export function getHotTags() {
	return request({
		  method: 'get',
		  url: '/tags/hot'
		})
}
export function listTagsDetail() {
	return request({
		  method: 'get',
		  url: '/tags/detail'
		})
}
~~~

# 5. 图标路径设置

将static目录 放入public下

# 1. 分类文章列表

## 1.1 路由

触发点击事件：

~~~js
 view(id) {
        this.$router.push({path: `/${this.activeName}/${id}`})
      },
~~~

路由：

~~~js
 {
          path: '/:type/:id',
          component: r => require.ensure([], () => r(require('@/views/blog/BlogCategoryTag')), 'blogcategorytag')
        }
~~~



## 1.2 页面

~~~js
<template>
	 <div class="me-ct-body" v-title :data-title="title">
	    <el-container class="me-ct-container">
	      <el-main>
	        <div class="me-ct-title me-area">
	          <template v-if="this.$route.params.type === 'tag'">
	            <img class="me-ct-picture" :src="ct.avatar?ct.avatar:defaultAvatar"/>
	            <h3 class="me-ct-name">{{ct.tagName}}</h3>
	          </template>
	
	          <template v-else>
	            <img class="me-ct-picture" :src="ct.avatar?ct.avatar:defaultAvatar"/>
	            <h3 class="me-ct-name">{{ct.categoryName}}</h3>
	            <p>{{ct.description}}</p>
	          </template>
	
	          <span class="me-ct-meta">{{ct.articles}} 文章</span>
	        </div>
	
	        <div class="me-ct-articles">
	          <article-scroll-page v-bind:query="article"></article-scroll-page>
	        </div>
	
	      </el-main>
	    </el-container>
	  </div>
</template>

<script>
	import defaultAvatar from '@/assets/img/logo.png'
	import ArticleScrollPage from "@/components/common/ArticleScrollPage"
	import {getTagDetailById} from "@/api/tag"
	import {getCategoryDetailById} from "@/api/category"
	export default {
		name: "BlogCategoryTag",
		data(){
			return {
				defaultAvatar: defaultAvatar,
				ct : {},
				article : {
					tagId:null,
					categoryId:null
				}
			}
		},
		created(){
			//进行后端请求 请求数据
			this.getCategoryOrTagAndArticles();
		},
		methods:{
			getCategoryOrTagAndArticles(){
				var type = this.$route.params.type;
				var id = this.$route.params.id;
				if('tag' == type){
					this.getTagDetailById(id);
					this.article.tagId = id;
				}
				if('category' == type){
					this.getCategoryDetailById(id);
					this.article.categoryId = id;
					
				}
			},
			getTagDetailById(id){
				//发起http请求 请求后端的数据
				getTagDetailById(id).then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.ct = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			},
			getCategoryDetailById(id){
				//发起http请求 请求后端的数据
				getCategoryDetailById(id).then((res)=>{
					////res.data = Result (success,msg,data)
					if(res.data.success){
						this.ct = res.data.data;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
				})
			}
		},
		computed:{
			title(){
				if(this.$route.params.type == 'tag'){
					return "标签-码神之路"
				}else{
					return "文章分类-码神之路"
				}
			}
		},
		components:{
			"article-scroll-page": ArticleScrollPage
		}
	}
</script>

<style>
  .me-ct-body {
    margin: 60px auto 140px;
    min-width: 100%;
  }

  .el-main {
    padding: 0;
  }

  .me-ct-title {
    text-align: center;
    height: 150px;
    padding: 20px;
  }

  .me-ct-picture {
    width: 60px;
    height: 60px;
  }

  .me-ct-name {
    font-size: 28px;
  }

  .me-ct-meta {
    font-size: 12px;
    color: #969696;
  }

  .me-ct-articles {
    width: 640px;
    margin: 30px auto;
  }

</style>

~~~

## 1.3 文章列表加条件

~~~js
<template>
		<scroll-page 
		:loading="loading" 
		:offset="offset" 
		:no-data="noData"
		@load="load">
			<ArticleItem
								  v-for="article in articles" 
								  v-bind="article"
								  :key="article.id">
			</ArticleItem>
		</scroll-page>
</template>

<script>
	import ScrollPage from "@/components/scrollpage"
	import ArticleItem from "@/components/article/ArticleItem"
	import {getArticles} from "@/api/article"
	export default {
		name:"ArticleScrollPage",
		props:{
			query:{
				type: Object,
				default(){
					return {}
				}
			}
		},
		data(){
			return {
				loading : false,
				noData : false,
				offset : 0,
				articles:[],
				innerPage:{
					page: 1,
					pageSize:10,
					tagId:null,
					categoryId:null
				}
			}
		},
		created(){
			this.getArticles();
		},
		methods:{
			load(){
				//如果触发分页，需要调用接口 加载文章列表
				this.getArticles();
			},
			getArticles(){
				this.loading = true;
				this.innerPage.tagId = this.query.tagId;
				this.innerPage.categoryId = this.query.categoryId;
				getArticles(this.innerPage).then((res)=>{
					//Result (success,msg,data)
					if(res.data.success){
						if(res.data.data.length <= 0){
							this.noData = true;
						}
						this.articles = this.articles.concat(res.data.data);
						this.innerPage.page += 1;
					}else{
						this.$message.error(res.data.msg);
					}
				}).catch((err)=>{
					this.$message.error("系统错误");
				}).finally(()=>{
					this.loading = false;
				})
				
				
			}
		},
		components:{
			"scroll-page":ScrollPage,
			ArticleItem
		}
	}
</script>

<style scoped>
  .el-card {
    border-radius: 0;
  }

  .el-card:not(:first-child) {
    margin-top: 10px;
  }
</style>

~~~

# 2. 文章详情

## 2.1 路由

~~~js
 {
          path: '/view/:id',
          component: r => require.ensure([], () => r(require('@/views/blog/BlogView')), 'blogview')
        },
~~~

## 2.2 页面

~~~html
<template>
  <div class="me-view-body" v-title :data-title="title">
    <el-container class="me-view-container">
      <!--<el-aside class="me-area">-->
        <!--<ul class="me-operation-list">-->
          <!--<li class="me-operation-item">-->
            <!--<el-button type="primary" icon="el-icon-edit"></el-button>-->
          <!--</li>-->
        <!--</ul>-->
      <!--</el-aside>-->
      <el-main>

        <div class="me-view-card">
          <h1 class="me-view-title">{{article.title}}</h1>
          <div class="me-view-author">
            <a class="">
              <img class="me-view-picture" :src="article.author.avatar"></img>
            </a>
            <div class="me-view-info">
              <span>{{article.author}}</span>
              <div class="me-view-meta">
                <span>{{article.createDate | format}}</span>
                <span>阅读   {{article.viewCounts}}</span>
                <span>评论   {{article.commentCounts}}</span>
              </div>

            </div>
            <el-button
              v-if="this.article.author.id == this.$store.state.id"
              @click="editArticle()"
              style="position: absolute;left: 60%;"
              size="mini"
              round
              icon="el-icon-edit">编辑</el-button>
          </div>
          <div class="me-view-content">
            <markdown-editor :editor=article.editor></markdown-editor>
          </div>

          <div class="me-view-end">
            <el-alert
              title="文章End..."
              type="success"
              center
              :closable="false">
            </el-alert>
          </div>

          <div class="me-view-tag">
            标签：
            <!--<el-tag v-for="t in article.tags" :key="t.id" class="me-view-tag-item" size="mini" type="success">{{t.tagName}}</el-tag>-->
            <el-button @click="tagOrCategory('tag', t.id)" size="mini" type="primary" v-for="t in article.tags" :key="t.id" round plain>{{t.tagName}}</el-button>
          </div>

          <div class="me-view-tag">
            文章分类：
            <!--<span style="font-weight: 600">{{article.category.categoryName}}</span>-->
            <el-button @click="tagOrCategory('category', article.category.id)" size="mini" type="primary" round plain>{{article.category.categoryName}}</el-button>
          </div>

          <div class="me-view-comment">
            <div class="me-view-comment-write">
              <el-row :gutter="20">
                <el-col :span="2">
                  <a class="">
                    <img class="me-view-picture" :src="avatar"></img>
                  </a>
                </el-col>
                <el-col :span="22">
                  <el-input
                    type="textarea"
                    :autosize="{ minRows: 2}"
                    placeholder="你的评论..."
                    class="me-view-comment-text"
                    v-model="comment.content"
                    resize="none">
                  </el-input>
                </el-col>
              </el-row>

              <el-row :gutter="20">
                <el-col :span="2" :offset="22">
                  <el-button type="text" @click="publishComment()">评论</el-button>
                </el-col>
              </el-row>
            </div>

            <div class="me-view-comment-title">
              <span>{{article.commentCounts}} 条评论</span>
            </div>

            <commment-item
              v-for="(c,index) in comments"
              :comment="c"
              :articleId="article.id"
              :index="index"
              :rootCommentCounts="comments.length"
              @commentCountsIncrement="commentCountsIncrement"
              :key="c.id">
            </commment-item>

          </div>

        </div>
      </el-main>

    </el-container>
  </div>
</template>

<script>
  import MarkdownEditor from '@/components/markdown/MarkdownEditor'
  import CommmentItem from '@/components/comment/CommentItem'
  import {viewArticle} from '@/api/article'
  import {getCommentsByArticle, publishComment} from '@/api/comment'

  import default_avatar from '@/assets/img/default_avatar.png'

  export default {
    name: 'BlogView',
    created() {
      this.getArticle()
    },
    watch: {
      '$route': 'getArticle'
    },
    data() {
      return {
        article: {
          id: '',
          title: '',
          commentCounts: 0,
          viewCounts: 0,
          summary: '',
          author: {},
          tags: [],
          category:{},
          createDate: '',
          editor: {
            value: '',
            toolbarsFlag: false,
            subfield: false,
            defaultOpen: 'preview'
          }
        },
        comments: [],
        comment: {
          article: {},
          content: ''
        }
      }
    },
    computed: {
      avatar() {
        let avatar = this.$store.state.avatar

        if (avatar.length > 0) {
          return avatar
        }
        return default_avatar
      },
      title() {
        return `${this.article.title} - 文章 - 码神之路`
      }
    },
    methods: {
      tagOrCategory(type, id) {
        this.$router.push({path: `/${type}/${id}`})
      },
      editArticle() {
        this.$router.push({path: `/write/${this.article.id}`})
      },
      getArticle() {
        let that = this
        viewArticle(that.$route.params.id).then(data => {
          Object.assign(that.article, data.data)
          that.article.editor.value = data.data.body.content

          that.getCommentsByArticle()
        }).catch(error => {
          if (error !== 'error') {
            that.$message({type: 'error', message: '文章加载失败', showClose: true})
          }
        })
      },
      publishComment() {
        let that = this
        if (!that.comment.content) {
          return;
        }
        that.comment.article.id = that.article.id
        let parms = {articleId:that.article.id,content:that.comment.content}
        publishComment(parms,this.$store.state.token).then(data => {
          if(data.success){
            that.$message({type: 'success', message: '评论成功', showClose: true})
            that.comment.content = ''
            that.comments.unshift(data.data)
            that.commentCountsIncrement()

          }else{
               that.$message({type: 'error', message: data.msg, showClose: true})
          }

        }).catch(error => {
          if (error !== 'error') {
            that.$message({type: 'error', message: '评论失败', showClose: true})
          }
        })
      },

      getCommentsByArticle() {
        let that = this
        getCommentsByArticle(that.article.id).then(data => {
          if(data.success){
               that.comments = data.data
          }else{
             that.$message({type: 'error', message: '评论加载失败', showClose: true})
          }
        }).catch(error => {
          if (error !== 'error') {
            that.$message({type: 'error', message: '评论加载失败', showClose: true})
          }
        })
      },
      commentCountsIncrement() {
        this.article.commentCounts += 1
      }
    },
    components: {
      'markdown-editor': MarkdownEditor,
      CommmentItem
    },
    //组件内的守卫 调整body的背景色
    beforeRouteEnter(to, from, next) {
      window.document.body.style.backgroundColor = '#fff';
      next();
    },
    beforeRouteLeave(to, from, next) {
      window.document.body.style.backgroundColor = '#f5f5f5';
      next();
    }
  }
</script>

<style>
  .me-view-body {
    margin: 100px auto 140px;
  }

  .me-view-container {
    width: 800px;
  }

  .el-main {
    overflow: hidden;
  }

  .me-view-title {
    font-size: 34px;
    font-weight: 800;
    line-height: 1.3;
  }

  .me-view-author {
    /*margin: 30px 0;*/
    margin-top: 30px;
    vertical-align: middle;
  }

  .me-view-picture {
    width: 40px;
    height: 40px;
    border: 1px solid #ddd;
    border-radius: 50%;
    vertical-align: middle;
    background-color: #5fb878;
  }

  .me-view-info {
    display: inline-block;
    vertical-align: middle;
    margin-left: 8px;
  }

  .me-view-meta {
    font-size: 12px;
    color: #969696;
  }

  .me-view-end {
    margin-top: 20px;
  }

  .me-view-tag {
    margin-top: 20px;
    padding-left: 6px;
    border-left: 4px solid #c5cac3;
  }

  .me-view-tag-item {
    margin: 0 4px;
  }

  .me-view-comment {
    margin-top: 60px;
  }

  .me-view-comment-title {
    font-weight: 600;
    border-bottom: 1px solid #f0f0f0;
    padding-bottom: 20px;
  }

  .me-view-comment-write {
    margin-top: 20px;
  }

  .me-view-comment-text {
    font-size: 16px;
  }

  .v-show-content {
    padding: 8px 25px 15px 30px !important;
  }

  .v-note-wrapper .v-note-panel {
    box-shadow: none !important;
  }

  .v-note-wrapper .v-note-panel .v-note-show .v-show-content, .v-note-wrapper .v-note-panel .v-note-show .v-show-content-html {
    background: #fff !important;
  }


</style>

~~~

## 2.3 markdowm编辑器

依赖：

~~~shell
npm install mavon-editor --save
~~~

/components/markdowm/MarkdownEditor.vue

~~~html
<template>
  <mavon-editor
    class="me-editor"
    ref="md"
    v-model="editor.value"
    @imgAdd="imgAdd"
    v-bind="editor">
  </mavon-editor>
</template>


<script>

  import {mavonEditor} from 'mavon-editor'
  import 'mavon-editor/dist/css/index.css'

  import {upload} from '@/api/upload'

  export default {
    name: 'MarkdownEditor',
    props: {
      editor: Object
    },
    data() {
      return {}
    },
    mounted() {
      this.$set(this.editor, 'ref', this.$refs.md)
    },
    methods: {
      imgAdd(pos, $file) {
        let that = this
        let formdata = new FormData();
        formdata.append('image', $file);

        upload(formdata).then(data => {
          // 第二步.将返回的url替换到文本原位置![...](./0) -> ![...](url)
          if (data.success) {

            that.$refs.md.$img2Url(pos, data.data);
          } else {
            that.$message({message: data.msg, type: 'error', showClose: true})
          }

        }).catch(err => {
          that.$message({message: err, type: 'error', showClose: true});
        })
      }
    },
    components: {
      mavonEditor
    }
  }
</script>
<style scoped>

  .me-editor {
    z-index: 6 !important;
  }

  .v-note-wrapper.fullscreen {
    top: 60px !important
  }
</style>

~~~

## 2.4 评论列表组件

/components/comment/CommentItem.vue

~~~vue
<template>
  <div class="me-view-comment-item">
    <div class="me-view-comment-author">
      <a class="">
        <img class="me-view-picture" :src="comment.author.avatar"></img>
      </a>
      <div class="me-view-info">
        <span class="me-view-nickname">{{comment.author.nickname}}</span>
        <div class="me-view-meta">
          <span>{{rootCommentCounts - index}}楼</span>
          <span>{{comment.createDate | format}}</span>
        </div>
      </div>
    </div>
    <div>
      <p class="me-view-comment-content">{{comment.content}}</p>
      <div class="me-view-comment-tools">
        <!--<a class="me-view-comment-tool">-->
        <!--<i class="el-icon-caret-top"></i> 20-->
        <!--</a>-->
        <a class="me-view-comment-tool" @click="showComment(-1,comment.author)">
          <i class="me-icon-comment"></i>&nbsp; 评论
        </a>
      </div>

      <div class="me-reply-list">
        <div class="me-reply-item" v-for="c in comment.childrens" :key="c.id">
          <div style="font-size: 14px">
            <span class="me-reply-user">{{c.author.nickname}}:&nbsp;&nbsp;</span>

            <span v-if="c.level == 2" class="me-reply-user">@{{c.toUser.nickname}} </span>

            <span>{{c.content}}</span>
          </div>
          <div class="me-view-meta">
            <span style="padding-right: 10px">{{c.createDate | format}}</span>
          <!--  <a class="me-view-comment-tool" @click="showComment(c.id, c.author)">
              <i class="me-icon-comment"></i>&nbsp;回复
            </a> -->
          </div>

        </div>

        <div class="me-view-comment-write" v-show="commentShow">

          <el-input
            v-model="reply.content"
            type="input"
            style="width: 90%"
            :placeholder="placeholder"
            class="me-view-comment-text"
            resize="none">
          </el-input>

          <el-button style="margin-left: 8px" @click="publishComment()" type="text">评论</el-button>

        </div>

      </div>

    </div>
  </div>
</template>

<script>
  import {publishComment} from '@/api/comment'

  export default {
    name: "CommentItem",
    props: {
      articleId: Number,
      comment: Object,
      index: Number,
      rootCommentCounts: Number
    },
    data() {
      return {
        placeholder: '你的评论...',
        commentShow: false,
        commentShowIndex: '',
        reply: this.getEmptyReply()
      }
    },
    methods: {
      showComment(commentShowIndex, toUser) {
        this.reply = this.getEmptyReply()

        if (this.commentShowIndex !== commentShowIndex) {
          if (toUser) {
            this.placeholder = `@${toUser.nickname} `
            this.reply.toUserId = toUser.id
          } else {
            this.placeholder = '你的评论...'
          }

          this.commentShow = true
          this.commentShowIndex = commentShowIndex
        } else {
          this.commentShow = false
          this.commentShowIndex = ''
        }
      },
      publishComment() {
        let that = this
        if (!that.reply.content) {
          return;
        }

        publishComment(that.reply,this.$store.state.token).then(data => {
          if(data.success){
            that.$message({type: 'success', message: '评论成功', showClose: true})
            if(!that.comment.childrens){
              that.comment.childrens = []
            }
            that.comment.childrens.unshift(data.data)
            that.$emit('commentCountsIncrement')
            that.showComment(that.commentShowIndex)
          }else{
             that.$message({type: 'error', message: data.msg, showClose: true})
          }
        }).catch(error => {
          if (error !== 'error') {
            that.$message({type: 'error', message: '评论失败', showClose: true})
          }
        })

      },
      getEmptyReply() {
        return {
          articleId: this.articleId,
          parent: this.comment.id,
          toUserId: '',
          content: ''
        }
      }
    }
  }
</script>

<style>
  .me-view-tag-item {
    margin: 0 4px;
  }

  .me-view-comment {
    margin-top: 60px;
  }

  .me-view-comment-title {
    font-weight: 600;
    border-bottom: 1px solid #f0f0f0;
    padding-bottom: 20px;
  }

  .me-view-comment-write {
    margin-top: 20px;
  }

  .me-view-comment-text {
    font-size: 16px;
  }

  .v-show-content {
    padding: 8px 25px 15px 30px !important;
  }

  .v-note-wrapper .v-note-panel {
    box-shadow: none !important;
  }

  .me-view-comment-item {
    margin-top: 20px;
    padding-bottom: 16px;
    border-bottom: 1px solid #f0f0f0;
  }

  .me-view-comment-author {
    margin: 10px 0;
    vertical-align: middle;
  }

  .me-view-nickname {
    font-size: 14px;
  }

  .me-view-comment-content {
    line-height: 1.5;
  }

  .me-view-comment-tools {
    margin-top: 4px;
    margin-bottom: 10px;
  }

  .me-view-comment-tool {
    font-size: 13px;
    color: #a6a6a6;
    padding-right: 14px;
  }

  .v-note-wrapper .v-note-panel .v-note-show .v-show-content, .v-note-wrapper .v-note-panel .v-note-show .v-show-content-html {
    background: #fff !important;
  }

  .me-reply-list {
    padding-left: 16px;
    border-left: 4px solid #c5cac3;
  }

  .me-reply-item {
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
  }

  .me-reply-user {
    color: #78b6f7;
  }
</style>

~~~

## 2.5 API

~~~js
export function viewArticle(id) {
  return request({
    url: `/articles/view/${id}`,
    method: 'post'
  })
}
export function getArticleById(id) {
  return request({
    url: `/articles/${id}`,
    method: 'post'
  })
}
~~~

~~~js
import request from '@/request'


export function getCommentsByArticle(id) {
  return request({
    url: `/comments/article/${id}`,
    method: 'get'
  })
}

export function publishComment(comment,token) {
  return request({
    headers: {'Authorization': token},
    url: '/comments/create/change',
    method: 'post',
    data: comment
  })
}

~~~



# 1. 注册

## 1.1 路由

~~~js
 {
      path: '/register',
      component: r => require.ensure([], () => r(require('@/views/Register')), 'register')
    }
~~~

## 1.2 注册页面

~~~html
<template>
  <div id="register" v-title data-title="注册 - 码神之路">
    <!--<video preload="auto" class="me-video-player" autoplay="autoplay" loop="loop">
          <source src="../../static/vedio/sea.mp4" type="video/mp4">
      </video>-->

    <div class="me-login-box me-login-box-radius">
      <h1>码神之路 注册</h1>

      <el-form ref="userForm" :model="userForm" :rules="rules">
        <el-form-item prop="account">
          <el-input placeholder="用户名" v-model="userForm.account"></el-input>
        </el-form-item>

        <el-form-item prop="nickname">
          <el-input placeholder="昵称" v-model="userForm.nickname"></el-input>
        </el-form-item>

        <el-form-item prop="password">
          <el-input placeholder="密码" type="password" v-model="userForm.password"></el-input>
        </el-form-item>

        <el-form-item size="small" class="me-login-button">
          <el-button type="primary" @click.native.prevent="register('userForm')">注册</el-button>
        </el-form-item>
      </el-form>

  

    </div>
  </div>
</template>

<script>
  import {register} from '@/api/login'

  export default {
    name: 'Register',
    data() {
      return {
        userForm: {
          account: '',
          nickname: '',
          password: ''
        },
        rules: {
          account: [
            {required: true, message: '请输入用户名', trigger: 'blur'},
            {max: 10, message: '不能大于10个字符', trigger: 'blur'}
          ],
          nickname: [
            {required: true, message: '请输入昵称', trigger: 'blur'},
            {max: 10, message: '不能大于10个字符', trigger: 'blur'}
          ],
          password: [
            {required: true, message: '请输入密码', trigger: 'blur'},
            {max: 10, message: '不能大于10个字符', trigger: 'blur'}
          ]
        }

      }
    },
    methods: {
      register(formName) {
        let that = this
        this.$refs[formName].validate((valid) => {
          if (valid) {

            that.$store.dispatch('register', that.userForm).then(() => {
              that.$message({message: '注册成功 快写文章吧', type: 'success', showClose: true});
              that.$router.push({path: '/'})
            }).catch((error) => {
              if (error !== 'error') {
                that.$message({message: error, type: 'error', showClose: true});
              }
            })

          } else {
            return false;
          }
        });

      }

    }
  }
</script>

<style scoped>
  #login {
    min-width: 100%;
    min-height: 100%;
  }

  .me-video-player {
    background-color: transparent;
    width: 100%;
    height: 100%;
    object-fit: fill;
    display: block;
    position: absolute;
    left: 0;
    z-index: 0;
    top: 0;
  }

  .me-login-box {
    position: absolute;
    width: 300px;
    height: 320px;
    background-color: white;
    margin-top: 150px;
    margin-left: -180px;
    left: 50%;
    padding: 30px;
  }

  .me-login-box-radius {
    border-radius: 10px;
    box-shadow: 0px 0px 1px 1px rgba(161, 159, 159, 0.1);
  }

  .me-login-box h1 {
    text-align: center;
    font-size: 24px;
    margin-bottom: 20px;
    vertical-align: middle;
  }

  .me-login-design {
    text-align: center;
    font-family: 'Open Sans', sans-serif;
    font-size: 18px;
  }

  .me-login-design-color {
    color: #5FB878 !important;
  }

  .me-login-button {
    text-align: center;
  }

  .me-login-button button {
    width: 100%;
  }

</style>

~~~

## 1.3 状态管理

![状态管理](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/state.png)

> 从上方的图中，可以看出，store的作用就是，将一些状态在各个组件中进行共享，比如说登录状态

**这里我们需要用到vuex**

> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

### 1.3.1 什么是“状态管理模式”？

让我们从一个简单的 Vue 计数应用开始：

~~~js
new Vue({
  // state
  data () {
    return {
      count: 0
    }
  },
  // view
  template: `
    <div>{{ count }}</div>
  `,
  // actions
  methods: {
    increment () {
      this.count++
    }
  }
})
~~~

这个状态自管理应用包含以下几个部分：

- **state**，驱动应用的数据源；
- **view**，以声明方式将 **state** 映射到视图；
- **actions**，响应在 **view** 上的用户输入导致的状态变化。

以下是一个表示“单向数据流”理念的简单示意：

![状态管理](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/flow.png)

但是，当我们的应用遇到**多个组件共享状态**时，单向数据流的简洁性很容易被破坏：

- 多个视图依赖于同一状态。
- 来自不同视图的行为需要变更同一状态。

对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。

对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。

因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！

通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。

![VUEX](https://raw.githubusercontent.com/SAH01/wordpress-img/master/imgs/vuex.png)

### 1.3.2 安装vuex

~~~js
npm install vuex --save
~~~

### 1.3.3 入门案例

~~~js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
~~~

可以通过 `store.state` 来获取状态对象，以及通过 `store.commit` 方法触发状态变更：

~~~js
store.commit('increment')

console.log(store.state.count) // -> 1
~~~



为了在 Vue 组件中访问 `this.$store` property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 `store` 选项的方式“注入”该 store 的机制：

~~~js
new Vue({
  el: '#app',
  store: store,
})
~~~

如果使用 ES6，你也可以以 ES6 对象的 property 简写 (用在对象某个 property 的 key 和被传入的变量同名时)：

```js
new Vue({
  el: '#app',
  store
})
```

现在我们可以从组件的方法提交一个变更：

~~~js
methods: {
  increment() {
    this.$store.commit('increment')
    console.log(this.$store.state.count)
  }
}
~~~

### 1.3.4 Mutation

更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：

~~~js
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  }
})
~~~

你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 `increment` 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法：

```js
store.commit('increment')
```

你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：

```js
// ...
mutations: {
  increment (state, n) {
    state.count += n
  }
}
store.commit('increment', 10)
```

在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：

```js
// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
store.commit('increment', {
  amount: 10
})
```

### 1.3.5 Action

Action 类似于 mutation，不同在于：

- Action 提交的是 mutation，而不是直接变更状态。
- Action 可以包含任意异步操作。

注册一个简单的 action：

~~~js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
~~~

Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。当我们在之后介绍到 [Modules](https://vuex.vuejs.org/zh/guide/modules.html) 时，你就知道 context 对象为什么不是 store 实例本身了。

实践中，我们会经常用到 ES2015 的 [参数解构 (opens new window)](https://github.com/lukehoban/es6features#destructuring)来简化代码（特别是我们需要调用 `commit` 很多次的时候）：

```js
actions: {
  increment ({ commit }) {
    commit('increment')
  }
}
```

#### 1.3.5.1 分发Action

Action 通过 `store.dispatch` 方法触发：

```js
store.dispatch('increment')
```

乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 **mutation 必须同步执行**这个限制么？Action 就不受约束！我们可以在 action 内部执行**异步**操作：

```js
actions: {
  incrementAsync ({ commit }) {
    setTimeout(() => {
      commit('increment')
    }, 1000)
  }
}
```

Actions 支持同样的载荷方式和对象方式进行分发：

```js
// 以载荷形式分发
store.dispatch('incrementAsync', {
  amount: 10
})

// 以对象形式分发
store.dispatch({
  type: 'incrementAsync',
  amount: 10
})
```

来看一个更加实际的购物车示例，涉及到**调用异步 API** 和**分发多重 mutation**：

```js
actions: {
  checkout ({ commit, state }, products) {
    // 把当前购物车的物品备份起来
    const savedCartItems = [...state.cart.added]
    // 发出结账请求，然后乐观地清空购物车
    commit(types.CHECKOUT_REQUEST)
    // 购物 API 接受一个成功回调和一个失败回调
    shop.buyProducts(
      products,
      // 成功操作
      () => commit(types.CHECKOUT_SUCCESS),
      // 失败操作
      () => commit(types.CHECKOUT_FAILURE, savedCartItems)
    )
  }
}
```

注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。

> 一个 `store.dispatch` 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。

## 1.4 Store

在src下创建store，在store下创建index.js

~~~js
import Vuex from 'vuex'
import Vue from 'vue'
import {register} from '@/api/login'

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    id: '',
    account: '',
    name: '',
    avatar: '',
    token: localStorage.token,
  },
  mutations: {
    SET_TOKEN: (state, token) => {
      state.token = token;
    },
    SET_ACCOUNT: (state, account) => {
      state.account = account
    },
    SET_NAME: (state, name) => {
      state.name = name
    },
    SET_AVATAR: (state, avatar) => {
      state.avatar = avatar
    },
    SET_ID: (state, id) => {
      state.id = id
    }
  },
  actions: {
    register({commit}, user) {
        //Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。
        //rejected: 意味着操作失败。
      return new Promise((resolve, reject) => {
          // 异步处理
    	 // 处理结束后、调用resolve 或 reject
         //sssssssssssssssss 当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)
        register(user.account, user.nickname, user.password).then((data) => {
          if(data.success){
            commit('SET_TOKEN', data.data)
            localStorage.token = data.data
            resolve()
          }else{
            reject(data.msg)
          }
        }).catch((error) => {
          reject(error)
        })
      })
    }
  }
})

~~~

## 1.5 在main.js引入

~~~js
import store from './store'
new Vue({
  router,
  store
  render: h => h(App),
}).$mount('#app')
~~~

# 2. 获取用户信息

## 2.1 拦截器

在请求或响应被 `then` 或 `catch` 处理前拦截它们。

~~~js
import store from '@/store'
import {Message} from 'element-ui'
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    if (store.state.token) {
    	config.headers['Authorization'] = localStorage.token
  	}
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
     const res = response.data;

    //0 为成功状态
    if (res.code !== 200) {

      //20001 用户未登录
      if (res.code === 90002) {

        Message({
          type: 'warning',
          showClose: true,
          message: '未登录或登录超时，请重新登录哦'
        })

        return Promise.reject('error');
      }
    }
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
~~~

## 2.2 导航守卫

> “导航”表示路由正在发生改变。

你可以使用 `router.beforeEach` 注册一个全局前置守卫：

~~~js
const router = new VueRouter({ ... })

router.beforeEach((to, from, next) => {
  // ...
})
~~~

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 **等待中**。

每个守卫方法接收三个参数：

- **`to: Route`**: 即将要进入的目标 [路由对象](https://router.vuejs.org/zh/api/#路由对象)
- **`from: Route`**: 当前导航正要离开的路由
- **`next: Function`**: 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next` 方法的调用参数。
    - **`next()`**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。
    - **`next(false)`**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
    - **`next('/')` 或者 `next({ path: '/' })`**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: 'home'` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。
    - **`next(error)`**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。

**确保 `next` 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错**。这里有一个在用户未能验证身份时重定向到 `/login` 的示例：

```js
// BAD
router.beforeEach((to, from, next) => {
  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
  // 如果用户未能验证身份，则 `next` 会被调用两次
  next()
})
// GOOD
router.beforeEach((to, from, next) => {
  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
  else next()
})
```

## 2.3 实现导航守卫

> 在跳转之前，如果localstorage中存在token，并且账号信息为空，则进行用户信息获取

~~~js
import store from '@/store'

router.beforeEach((to, from, next) => {

  if (store.state.token) {

    if (to.path === '/login') {
      next({path: '/'})
    } else {
      if (store.state.account.length === 0) {
        store.dispatch('getUserInfo').then(data => { //获取用户信息
            next()
        }).catch(() => {
          Message({
            type: 'warning',
            showClose: true,
            message: '登录已过期'
          })
          next({path: '/'})
        })
      } else {

        next()
      }
    }
  } else {
    if (to.matched.some(r => r.meta.requireLogin)) {
      Message({
        type: 'warning',
        showClose: true,
        message: '请先登录哦'
      })

    }
    else {
      next();
    }
  }
})
~~~

## 2.4 获取用户信息

~~~js
export function getUerInfo() {
	
	return request({
		  method: 'get',
		  url: '/users/currentUser'
		})
}
~~~



~~~js
 // 获取用户信息
    getUserInfo({commit, state}) {

      let that = this
      return new Promise((resolve, reject) => {
        getUserInfo(state.token).then(data => {
          if (data.success) {
            commit('SET_ACCOUNT', data.data.account)
            commit('SET_NAME', data.data.nickname)
            commit('SET_AVATAR', data.data.avatar)
            commit('SET_ID', data.data.id)
            resolve(data)
          } else {
            commit('SET_ACCOUNT', '')
            commit('SET_NAME', '')
            commit('SET_AVATAR', '')
            commit('SET_ID', '')
            removeToken()
            resolve(data)
          }

        }).catch(error => {
          commit('SET_ACCOUNT', '')
          commit('SET_NAME', '')
          commit('SET_AVATAR', '')
          commit('SET_ID', '')
          removeToken()
          reject(error)
        })
      })
    }
~~~

# 3. 登录信息显示

~~~js
computed: {
      user() {
        let login = this.$store.state.account.length != 0
        let avatar = this.$store.state.avatar
        return {
          login, avatar
        }
      }
    }
~~~

# 4. 退出登录

~~~js
logout() {
        let that = this
        this.$store.dispatch('logout').then(() => {
          this.$router.push({path: '/'})
        }).catch((error) => {
          if (error !== 'error') {
            that.$message({message: error, type: 'error', showClose: true});
          }
        })
      }
~~~

~~~js
// 退出
    logout({commit, state}) {
      return new Promise((resolve, reject) => {
        logout(state.token).then(data => {
          if(data.success){

            commit('SET_TOKEN', '')
            commit('SET_ACCOUNT', '')
            commit('SET_NAME', '')
            commit('SET_AVATAR', '')
            commit('SET_ID', '')
             localStorage.removeItem('token')
            resolve()
          }

        }).catch(error => {
          reject(error)
        })
      })
    },
~~~

~~~js
export function logout() {
  return request({
    url: '/logout',
    method: 'get'
  })
}
~~~

# 5. 登录

## 5.1 路由

~~~js
 {
      path: '/login',
      component: r => require.ensure([], () => r(require('@/views/Login')), 'login')
 }
~~~

## 5.2 页面

~~~html
<template>
  <div id="login" v-title data-title="登录 - 码神之路">
    <!--<video preload="auto" class="me-video-player" autoplay="autoplay" loop="loop">
          <source src="../../static/vedio/sea.mp4" type="video/mp4">
      </video>-->

    <div class="me-login-box me-login-box-radius">
      <h1>码神之路 登录</h1>

      <el-form ref="userForm" :model="userForm" :rules="rules">
        <el-form-item prop="account">
          <el-input placeholder="用户名" v-model="userForm.account"></el-input>
        </el-form-item>

        <el-form-item prop="password">
          <el-input placeholder="密码" type="password" v-model="userForm.password"></el-input>
        </el-form-item>

        <el-form-item size="small" class="me-login-button">
          <el-button type="primary" @click.native.prevent="login('userForm')">登录</el-button>
        </el-form-item>
      </el-form>

    </div>
  </div>
</template>

<script>
  export default {
    name: 'Login',
    data() {
      return {
        userForm: {
          account: '',
          password: ''
        },
        rules: {
          account: [
            {required: true, message: '请输入用户名', trigger: 'blur'},
            {max: 10, message: '不能大于10个字符', trigger: 'blur'}
          ],
          password: [
            {required: true, message: '请输入密码', trigger: 'blur'},
            {max: 10, message: '不能大于10个字符', trigger: 'blur'}
          ]
        }
      }
    },
    methods: {
      login(formName) {
        let that = this

        this.$refs[formName].validate((valid) => {
          if (valid) {

            that.$store.dispatch('login', that.userForm).then(() => {
                that.$router.go(-1)
            }).catch((error) => {
              if (error !== 'error') {
                that.$message({message: error, type: 'error', showClose: true});
              }
            })
          } else {
            return false;
          }
        });
      }
    }
  }
</script>

<style scoped>
  #login {
    min-width: 100%;
    min-height: 100%;
  }

  .me-video-player {
    background-color: transparent;
    width: 100%;
    height: 100%;
    object-fit: fill;
    display: block;
    position: absolute;
    left: 0;
    z-index: 0;
    top: 0;
  }

  .me-login-box {
    position: absolute;
    width: 300px;
    height: 260px;
    background-color: white;
    margin-top: 150px;
    margin-left: -180px;
    left: 50%;
    padding: 30px;
  }

  .me-login-box-radius {
    border-radius: 10px;
    box-shadow: 0px 0px 1px 1px rgba(161, 159, 159, 0.1);
  }

  .me-login-box h1 {
    text-align: center;
    font-size: 24px;
    margin-bottom: 20px;
    vertical-align: middle;
  }

  .me-login-design {
    text-align: center;
    font-family: 'Open Sans', sans-serif;
    font-size: 18px;
  }

  .me-login-design-color {
    color: #5FB878 !important;
  }

  .me-login-button {
    text-align: center;
  }

  .me-login-button button {
    width: 100%;
  }

</style>

~~~

## 5.3 action

~~~js
login({commit}, user) {
      return new Promise((resolve, reject) => {
        login(user).then(res => {
          if(res.data.success){
            commit('SET_TOKEN', res.data.data)
            localStorage.token=res.data.data;
            resolve()
          }else{
            reject(res.data.msg)
          }
        }).catch(error => {
          reject(error)
        })
      })
    }
~~~

## 5.4 API

~~~js
export function login(data) {
  return request({
    url: '/login',
    method: 'post',
    data
  })
}
~~~

