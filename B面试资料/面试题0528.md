# 01 面向对象的特征

1. 封装：隐藏部分对象的属性和实现细节，以不同的访问级别来保护对象内部的数据，防止外部程序的不当访问，对外提供公开的接口。【私有的属性，共有的方法】

2. 继承：子类自动共享父类数据和方法。

3. 多态：对于同一个行为，不同的子类对象具有不同的表现形式。同一个事件发生在不同的对象上会产生不同的结果。

    ==编译时类型和运行时类型不一致==

    【举例：Person类拥有task方法 Student和Teacher继承 其中学生的任务的学习 老师的任务的教学】

> 封装：私有的属性 共有的方法
>
> 继承：子类共享父类
>
> 多态：不同子对象对同一行为有不同表现形式
>
> 封装的例子
>
> 比如司机踩刹车让车停下来
>
> 踩刹车这个动作应该分配给车而不是司机，因为只有车自己内部才能让自己停下来，而司机要做的仅仅的踩一下刹车器，这样的话就是把刹车封装在了车这个实体类里，人只是调用车开放的刹车接口就可以完成刹车这件事。

# 02 &和&&的区别？

==都是逻辑与 &&有短路性 &一般作为 按位与运算符==

> 重点说短路和按位与

# 03 String 是 Java 基本数据类型吗？可以被继承吗？

**String 类使用 final 修饰，无法被继承**

不是。Java 中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type）。

基本数据类型：数据直接存储在栈上

引用数据类型区别：数据存储在堆上，栈上只存储引用地址

> String类不可继承 final修饰
>
> 基本数据类型8个
>
> 基本数据类型是放在栈上
>
> 引用数据类型的值放在堆上，栈只保存引用地址

# 03 浅谈JDK、JRE、JVM区别与联系

JDK(Java Development Kit) 是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是JVM（Java Virtual Machine），lib中则是JVM工作所需要的类库，而JVM和 lib合起来就称为JRE（Java Runtime Environment，Java运行环境）。

JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，**我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。**

> JDK 开发环境
>
> JRE 运行环境
>
> JVM 虚拟机

# 04 String和StringBuilder、StringBuffer的区别？

String：==String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。==

StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。

StringBuilder：==StringBuffer 的非线程安全版本，没有使用 synchronized，具有更高的性能，推荐优先使用。==

> String不可直接改变值，只要改变值本质上是创建了一个新的对象
>
> StringBuilder 可以改变值 线程不安全



# 05 重载（Overload）和重写（Override）的区别？

方法的重载和重写都是实现多态的方式，区别在于==重载实现的是编译时的多态性，而重写实现的是运行时的多态性。==

重载：一个类中有多个同名的方法，但是具有有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。

重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。

> 重载 方法同名不同参
>
> 重写 子类重写父类，只能是返回值不一样，其他的保持一致



## 05 抽象类（abstract class）和接口（interface）有什么区别？

普通类像亲爹 ，他有啥都是你的。

抽象类像叔伯，有一部分会给你，还能指导你做事的方法。

接口像干爹，可以给你指引方法，但是做成啥样得你自己努力实现。

> 抽象类更像普通类 接口次之
>
> 抽象类不清楚自己能做什么不能做什么 接口是什么都不做 只提供思想（方法）

# 06 Error 和 Exception 有什么区别？

Error 和 Exception 都是 Throwable 的子类

Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。

Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。

> error表示最高级的错误，程序没办法处理，而且一定会终止程序的运行。
>
> exception次之，分为系统异常和普通异常
>
> ==java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处理或用 throws 声明继续抛给上层调用方法处理，==所以**普通异常也称为 checked 异常**，而系统异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以**系统异常也称为 unchecked 异常**。



# 07 ArrayList 和 Vector 的区别

动态 索引 有序 实现了List接口 List接口继承了Collection接口

> Vector 线程安全 ArrayList不是

# 08 ArrayList 和 LinkedList 的区别

ArrayList 底层基于动态数组实现，LinkedList 底层基于链表实现

索引 ArrayList > LinkedList 

随机插入和删除 ArrayList < LinkedList 

顺序插入和删除 ArrayList > LinkedList 

# 09 HashMap 和Hashtable 的区别

HashMap 允许 key 和 value 为 null，Hashtable 不允许。

HashMap 是非线程安全的，Hashtable是线程安全的。

HashMap 去掉了 Hashtable 中的 contains 方法。

# 10 编译和运行的区别

> **编译时类型指在声明对象时所采用的类型**
>
> **运行时类型指为对象赋值时所采用的类型**

1.编译就是将java代码交给编译器进行语法检查，如果没有错误就生成.class文件

2.运行就是将字节码文件(.class)交给java虚拟机执行，如果没有逻辑错误，就成功出现结果。

**编译期和运行期内存的分配**

1.编译期仅仅知道内存分配的位置和大小，不做具体的分配操作

2.运行期确定真正的分配，确定分配的大小以及位置

**常见的错误**

1.编译错误是常见的语法错误：缺少分号，大小写

2.运行错误是逻辑错误：空指针异常，越界访问，除数为0等

==已检查的异常是被编译器在编译时候已经检查过的异常，这些异常需要在try/catch块中处理的异常。==

> 编译时：重载、泛型(类型检测) 		List<String> arrayList = new ArrayList<String>();
>
> 运行时：重写

# 11 什么是Java反射

> Java反射就是==在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；==
>
> 对于任意==一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。==

```
通过对象调用 getClass() 方法
直接通过 类名.class 的方式
通过 Class 对象的 forName() 静态方法来获取
```

# 12 设计模式六大原则

> 开闭：对扩展开放，对修改关闭
>
> 里氏代换：任何基父类可以出现的地方，子类一定可以出现。
>
> 依赖倒转：针对接口编程，依赖于抽象而不依赖于具体。
>
> 接口隔离：用分开的小接口
>
> 迪米特法则：实体间尽可能少的发生相互作用
>
> 合成复用：多用合成聚合，少用继承



# 13 事务的ACID

1. 原子性**Atomicity**：事务是一个不可分割的工作单元，事务里的操作要么都成功，要么都失败，如果事务执行失败，则需要进行回滚。（回滚）
2. 一致性**Consistency**：事务前后数据的完整性必须保持一致。
3. 隔离性**Consistency**：数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
4. 持久性**Durability**：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的。

# 14 事务的隔离级别

1. 脏读：一个事务读取了另外一个事务未提交的数据。（强调数据被修改但是未提交成功，事务回滚了，导致刚开始读的数据已经没了）
2. 丢失修改：事务A修改了数据，当再次读取时发现自己的修改失效了，因为有其他事务覆盖了事务A的修改结果。（强调某事务的修改被覆盖）
3. 不可重复读：在一个事务内，多次读取同一个数据，值不一样。（强调其他事务中途修改数据值）
4. 幻读：在一个事务中，先后两次范围查询相同的数据，得到的数据条数不一样。（强调其他事务中途删除或者新增数据）

**4个隔离级别**

- 读未提交：允许事务在执行过程中，读取其他事务尚未提交的数据；
- 读已提交：允许事务在执行过程中读取其他事务已经提交的数据；
- 可重复读（默认级别）：在同一个事务内，任意时刻的查询结果都是一致的；
- 读序列化：所有事务逐个依次执行，每次读都需要获取表级共享锁，读写会相互阻塞。

![img](https://gitee.com/yang-chuanwei/typora-img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70.png)

# 15 InnoDB与MyISAM的区别

（1）事务：MyISAM不支持事务，InnoDB支持事务。

（2）锁级别：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，默认使用行级锁，但是行锁只有通过索引查询数据才会使用，否则将使用表锁。

（3）主键和外键：MyISAM 允许没有任何索引和主键的表存在，不支持外键。InnoDB的主键不能为空且支持主键自增长，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键，支持外键完整性约束。

（4）索引结构：MyISAM 和 InnoDB 都是使用B+树索引，MyISAM的主键索引和辅助索引的Data域都是保存行数据记录的地址。但是InnoDB的主键索引的Data域保存的不是行数据记录的地址，而是保存该行的所有数据内容，而辅助索引的Data域保存的则是主索引的值。

# 16 InnoDB的行锁

- 共享锁（S锁、读锁）：多个事务可以对同一数据行共享一把S锁，但只能进行读不能修改；
- 排它锁（X锁、写锁）：一个事务获取排它锁之后，可以对锁定范围内的数据行执行写操作，在锁定期间，其他事务不能再获取这部分数据行的锁（共享锁、排它锁），只允许获取到排它锁的事务进行更新数据。

# 17 mysql索引

MySQL语句的查询效率主要和**索引树的高度**有关，想要降低查询的次数提高查询的速度，**减少直接对磁盘的I/O流的次数**，就要让**索引树的高度越低越好**。

**索引的定义：**索引是帮助MySQL高效获取数据的排好序的数据结构。

> 关键要指出来，想要查询快速，就需要减少IO次数。也就是让索引树的高度降低。


