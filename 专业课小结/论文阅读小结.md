# 论文阅读小结

## 一、B／S 和 C／S 软件体系结构选择

### 1） C／S 、 B／S 结构概述

C／S 结构，即 Client／Server （客户机 ／ 服务器 ）， C／S 结构软件分为**客户机和服务器两层**，在此结构中 ，客户机硬件环境的优势被充分利用，具有一定的数据处理和数据存储能力，通过把应用软件的计算和数据合理地分配在客户机和服务器两端，可以有效地降低网络通讯开销和服务器运算量 。

B／S 结构，即 Browser／Server( 浏览器 ／ 服务器 )用户界面完全通过 WWW 浏览器实现 ，一部分事务逻辑在前端实现 ，但是**主要事务逻辑在服务器端实现**（如MVC三层结构）。典型的三层体系结构由表示层（Presentation）、领域层( Do-main )及基础架构层（Infrastructure）组成。

### 2） C／S 、 B／S 结构技术上的比较

1. **交互上**：C/S强于B/S。 C／S 结构一般采用专门的局域网，而 B／S 体系结构的数据提交一般以页面为单位 ，数据的动态交互性不强 ，不 利 于 在 线 事 务 处 理 应 用 。

2. **数据一致性**：C/S结构弱于B/S结构，因为C/S结构的软件需要各地安装区域服务器，然后再数据同步，这些区域服务器必须每天汇总到总部，才能同步数据库信息。但是B/S结构的软件，数据集中存储在中央数据库，不存在数据一致性问题。

3. **数据实时性**：==C/S结构的软件实际上用户看到的数据已经是历史数据了，而B/S结构的软件可以让用户实时看到业务数据的变化==。

4. **数据溯源性**：由于 B／S 结构的数据是集中存放的 ，所以在服务器端可以直接追溯到各个客户端的原始业务单据，也就是说看到的结果可溯源。大部分 C／S 结构的软件为了减少数据通信量 ，仅仅上传中间报表数据，在服务器端不可能查到各分支机构中客户端的原始单据。

5. **服务响应及时性**：C/S结构的应用是分布的，一旦需要业务升级，需要对每一个使用节点重新进行程序安装，所以，即使非常小的程序缺陷都需要很长的重新部署时间。重新部署时 ，为了保证各程序版本的一致性，必须暂停一切业务进行更新，其服务响应时间基本不可忍受。但是B/S结构的软件应用集中部署在总服务器上，响应快，更新容易。

6. **应用服务器运行数据负荷**：C/S运载负荷小，因为客户的应用程序运行在自己的电脑上，而B/S结构不是。

7. **系统的性能方面**：采用 C／S 结构时 ，客户端能充分发挥自有的处理能力 ，很多工作可以在客户端处理后再提交给服务器。 对应的优点就是客户端响应速度快。

    B／S 占有优势的是其异地浏览和信息采集的灵活性 。 任何时间、任何地点、任何系统，只要可以使用浏览器上网，就可以使用 B／S 系统的终端 。但是B/S结构的服务器负担很重，而且HTML格式的文件导致文件管理成为一个问题，所以B/S结构在数据响应速度上可能会远远低于C/S结构。

8. **数据安全性**：B/S结构采用TCP／IP 这一类运用于 Internet 的开放性协议，建立在广域网上，面向不可知用户群，安全性较差。而C/S结构建立在局域网上，一般面向的是特定的用户群，在交互中的安全性C/S强于B/S。但是==由于C/S的数据安装在多个服务器，一旦发生不可抗力因素（比如火灾等），数据容易丢失且很难找回==。

9. **网络应用限制**：C／S 结构软件仅适用于局域网内部用户或宽带用户；而 B／S 结构软件可以适用于任何网络结构，特别适于宽带不能到达的地方。

### 3） C／S 、 B／S 结构软件商业运用上的比较（成本）

1. **投入**：B／S 结构软件一般只有初期一次性投入成本。而 C／S 结构的软件则不同 ，随着应用范围的扩大，投资会连绵不绝 。
2. **维护**： 当应用范围扩大 ，系统负载上升时 ， C／S 结构软件的一般解决方案是购买更高级的中央服务器，原服务器放弃不用，这是由于 C／S 软件的两层结构造成的。而B／S 结构可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡，有效地保护了原有硬件投资 。
3. **升级**：C／S 结构的软件来讲 ， 由于必须同时安装服务器和客户端 、建设机房 、招聘专业管理人员等 ，所以无法适应企业快速扩张的特点 。 而 B／S 结构软件 ，只需一次安装 ，以后只需设立账号 、培训即可 。 

-----

## 二、面向对象技术在软件体系结构中的应用

### 1） 软件体系结构

软件体系结构是一个程序或系统的构件的组织结构、它们之间的关联关系以及支配系统设计和演变的原则和方针 。通常，**一个系统的软件体系结构描述了该系统中的所有计算构件、构件之间的交互、连接件以及如何将构件和连接件结合在一起的约束。**

软件体系结构的重要属性：

1. 在足够高层次上对系统进行抽象, 使系统能作一个整体来看待;
2. 体系结构必须支持系统的功能需求, 也就是说, 系统的动态行为必须在设计结构时考虑进去。
3. 对非功能性需求（系统限制等）以及功能性需求（性能、安全性、可靠性、灵活性、可扩展性）的要求要进行==权衡分析==，力求最小的改动成本。
4. 体系结构上, 所有的实现==细节应该被隐藏==。
5. 开放性：软件系统的开放性包括数据的开放性、功能的开放性和系统的可扩充性。
6. 部件和连接器:部件是可识别的, 并且赋予一定的任务, 客户端的部件通过已定义好的接口进行交互作用;控件间的连接器详细描述了通信和控制机制,支持所有的部件间的交互作用, 以实现系统的行为。

### 2） 面向对象的系统模型

![image-20220406090554128](https://gitee.com/yang-chuanwei/typora-img/raw/master/img/image-20220406090554128.png)

系统内核对象中封装的是能为用户界面对象和所有应用对象所共享的数据及相应的操作;用户界面对象中封装的是用户界面数据及相应的操作;应用对象中封装的是应用数据及相应的操作。 所有这些对象通过相互间的通讯协调来完成指定的功能。从系统构成的角度来说, 这类模型的结构是无中心的,==系统由各对象实体构成, 各对象实体具有平等的地位==。

优点：数据和功能的合理封装**降低了由于数据和功能的集中管理所带来的通讯上的开销和操作上的复杂性**;另外, 系统的**无中心结构**也使系统的构成变得更加灵活 。

### 3） 基于总线的系统模型

![image-20220406090733551](https://gitee.com/yang-chuanwei/typora-img/raw/master/img/image-20220406090733551.png)

基于总线的系统模型仍然是一种面向对象的结构, 但**系统中的对象是按照规范设计的模块**, 这些定义良好的软件模块(构件) 在系统中共存, 并且充分地相互作用。 按照这种结构, ==可以将若干构件组合起来, 以建立更大和更复杂的系统==。这种模型的关键在于一种高效的总线结构, 使构件之间能以一个公共的接口互相连接, 做到**构件的即插即用, 无缝集成。** 

### 4） 分布式对象技术

分布对象技术采用面向对象的**多层客户/服务器**计算模型, 该模型将分布在网络上的全部资源( 无论是系统层还是应用层)都按照对象的概念来组织, **每个对象都有定义明晰的访问接口**。 服务器中的分布对象不仅能够被访问, 而且自身也可能作为其他对象的客户。因此, 在分布对象技术中, ==客户与服务器的角色划分是相对的或多层次的==。 分布式对象是指对象位置透明( 对象可存在于网络的任何地方) , 语言独立和平台独立地相互发送消息, 实现请求服务, 并能被远程客户应用程序以方法调用的形式访问的实体。

## 三、软件体系结构中五种常见风格的剖析

### 1） 管道和过滤器 (Pips and Filters)

每个部件都有一组输入和输出，每个部件从自己的输入读入数据流，再从自己的输出产出数据流，依此按照一个标准顺序来得到一个完整的结果。在输入流上应用一个过滤器，完成逻辑转换和递进的计算过程。过滤器位于管道的两端，而每个过滤器并不知道上下端过滤器的身份，比如Unix内核进程控制。

### 2） 数据抽象和面向对象结构（Data Abstraction and Object-oriented Organization）

数据表示和与之相连的原语操作（primitive operation）被封装在一个抽象数据类型或对象之中。这种风格的部件是对象，也可以成为抽象数据类型的实例。对象通过函数和过程调用进行交互。

这种风格的两个特征是：

- 对象负责维护其表示的完整性（属性和方法）
- 对象的表示对于其他的对象而言是隐藏的

### 3）基于事件的隐式调用（Event-based Implicit Invocation）

部件不再直接调用一个过程，而是声明（或者广播）一个或多个事件。**系统中的其他部件可以通过一个与这个或这些事件相联系的过程，在这个或这些事件中进行登记。**当事件被声明时，系统会自动调用所有在这个或这些时间中登记过的过程。因此，一个事件的隐式调用会触发其他模块中的过程。

### 4）分层系统（Layered Systems）

系统分层次组织，每层对上层提供服务，同时对下层而言是一个客户。

![image-20220406124634967](https://gitee.com/yang-chuanwei/typora-img/raw/master/img/image-20220406124634967.png)

- 支持渐进式抽象层次设计
- 支持扩充（因为只有相邻的层次直接交互，耦合性低）
- 支持重用（接口）

### 5）仓库（Repositories）

两个部件：

- 中心数据结构代表现在的状态
- 独立部件的集合对中心数据进行操作

两种类别：

- 由输入事务流选择进程执行，这是传统的数据库。
- 由中心数据结构来选择要执行的过程，这个仓库就是黑板。

![image-20220406125122877](https://gitee.com/yang-chuanwei/typora-img/raw/master/img/image-20220406125122877.png)

黑板结构分为三部分：

1. 知识源：分离的基于应用知识的独立包。
2. 黑板数据中心：用以解决问题的状态数据，被组织成一个基于应用的层次结构。
3. 控制：由黑板状态驱动，当知识源判断黑板的改变是否合适时，知识源会作出回应。

这个结构常用于需要对信号进行复杂解释的应用，如语言和模式识别，黑板中心相当于是一个共享资源库，它和知识源互相影响，共同解决问题，我觉得黑板更像一个工具书（比如字典，字典可以给字带来解释，而字的新含义等也可以重新修缮字典的内容）。

